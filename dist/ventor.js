webpackJsonp([49],{

/***/ 14:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapState\", function() { return mapState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapMutations\", function() { return mapMutations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapGetters\", function() { return mapGetters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapActions\", function() { return mapActions; });\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * vuex v2.3.0\n * (c) 2017 Evan You\n * @license MIT\n */\nvar applyMixin = function applyMixin(Vue) {\n  var version = Number(Vue.version.split('.')[0]);\n\n  if (version >= 2) {\n    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init;\n    Vue.prototype._init = function (options) {\n      if (options === void 0) options = {};\n\n      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;\n      _init.call(this, options);\n    };\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit() {\n    var options = this.$options;\n    // store injection\n    if (options.store) {\n      this.$store = options.store;\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store;\n    }\n  }\n};\n\nvar devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\nfunction devtoolPlugin(store) {\n  if (!devtoolHook) {\n    return;\n  }\n\n  store._devtoolHook = devtoolHook;\n\n  devtoolHook.emit('vuex:init', store);\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState);\n  });\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state);\n  });\n}\n\n/**\n * Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}\n */\n/**\n * Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}\n */\n\n/**\n * forEach for object\n */\nfunction forEachValue(obj, fn) {\n  Object.keys(obj).forEach(function (key) {\n    return fn(obj[key], key);\n  });\n}\n\nfunction isObject(obj) {\n  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\nfunction isPromise(val) {\n  return val && typeof val.then === 'function';\n}\n\nfunction assert(condition, msg) {\n  if (!condition) {\n    throw new Error(\"[vuex] \" + msg);\n  }\n}\n\nvar Module = function Module(rawModule, runtime) {\n  this.runtime = runtime;\n  this._children = Object.create(null);\n  this._rawModule = rawModule;\n  var rawState = rawModule.state;\n  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};\n};\n\nvar prototypeAccessors$1 = { namespaced: {} };\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced;\n};\n\nModule.prototype.addChild = function addChild(key, module) {\n  this._children[key] = module;\n};\n\nModule.prototype.removeChild = function removeChild(key) {\n  delete this._children[key];\n};\n\nModule.prototype.getChild = function getChild(key) {\n  return this._children[key];\n};\n\nModule.prototype.update = function update(rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced;\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions;\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations;\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters;\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild(fn) {\n  forEachValue(this._children, fn);\n};\n\nModule.prototype.forEachGetter = function forEachGetter(fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn);\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction(fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn);\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation(fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn);\n  }\n};\n\nObject.defineProperties(Module.prototype, prototypeAccessors$1);\n\nvar ModuleCollection = function ModuleCollection(rawRootModule) {\n  var this$1 = this;\n\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false);\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, function (rawModule, key) {\n      this$1.register([key], rawModule, false);\n    });\n  }\n};\n\nModuleCollection.prototype.get = function get(path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key);\n  }, this.root);\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace(path) {\n  var module = this.root;\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key);\n    return namespace + (module.namespaced ? key + '/' : '');\n  }, '');\n};\n\nModuleCollection.prototype.update = function update$1(rawRootModule) {\n  update(this.root, rawRootModule);\n};\n\nModuleCollection.prototype.register = function register(path, rawModule, runtime) {\n  var this$1 = this;\n  if (runtime === void 0) runtime = true;\n\n  var parent = this.get(path.slice(0, -1));\n  var newModule = new Module(rawModule, runtime);\n  parent.addChild(path[path.length - 1], newModule);\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime);\n    });\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister(path) {\n  var parent = this.get(path.slice(0, -1));\n  var key = path[path.length - 1];\n  if (!parent.getChild(key).runtime) {\n    return;\n  }\n\n  parent.removeChild(key);\n};\n\nfunction update(targetModule, newModule) {\n  // update target module\n  targetModule.update(newModule);\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        console.warn(\"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" + 'manual reload is needed');\n        return;\n      }\n      update(targetModule.getChild(key), newModule.modules[key]);\n    }\n  }\n}\n\nvar Vue; // bind on install\n\nvar Store = function Store(options) {\n  var this$1 = this;\n  if (options === void 0) options = {};\n\n  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\");\n  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\");\n\n  var state = options.state;if (state === void 0) state = {};\n  var plugins = options.plugins;if (plugins === void 0) plugins = [];\n  var strict = options.strict;if (strict === void 0) strict = false;\n\n  // store internal state\n  this._committing = false;\n  this._actions = Object.create(null);\n  this._mutations = Object.create(null);\n  this._wrappedGetters = Object.create(null);\n  this._modules = new ModuleCollection(options);\n  this._modulesNamespaceMap = Object.create(null);\n  this._subscribers = [];\n  this._watcherVM = new Vue();\n\n  // bind commit and dispatch to self\n  var store = this;\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n  this.dispatch = function boundDispatch(type, payload) {\n    return dispatch.call(store, type, payload);\n  };\n  this.commit = function boundCommit(type, payload, options) {\n    return commit.call(store, type, payload, options);\n  };\n\n  // strict mode\n  this.strict = strict;\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root);\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state);\n\n  // apply plugins\n  plugins.concat(devtoolPlugin).forEach(function (plugin) {\n    return plugin(this$1);\n  });\n};\n\nvar prototypeAccessors = { state: {} };\n\nprototypeAccessors.state.get = function () {\n  return this._vm._data.$$state;\n};\n\nprototypeAccessors.state.set = function (v) {\n  assert(false, \"Use store.replaceState() to explicit replace store state.\");\n};\n\nStore.prototype.commit = function commit(_type, _payload, _options) {\n  var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n  var type = ref.type;\n  var payload = ref.payload;\n  var options = ref.options;\n\n  var mutation = { type: type, payload: payload };\n  var entry = this._mutations[type];\n  if (!entry) {\n    console.error(\"[vuex] unknown mutation type: \" + type);\n    return;\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator(handler) {\n      handler(payload);\n    });\n  });\n  this._subscribers.forEach(function (sub) {\n    return sub(mutation, this$1.state);\n  });\n\n  if (options && options.silent) {\n    console.warn(\"[vuex] mutation type: \" + type + \". Silent option has been removed. \" + 'Use the filter functionality in the vue-devtools');\n  }\n};\n\nStore.prototype.dispatch = function dispatch(_type, _payload) {\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n  var type = ref.type;\n  var payload = ref.payload;\n\n  var entry = this._actions[type];\n  if (!entry) {\n    console.error(\"[vuex] unknown action type: \" + type);\n    return;\n  }\n  return entry.length > 1 ? Promise.all(entry.map(function (handler) {\n    return handler(payload);\n  })) : entry[0](payload);\n};\n\nStore.prototype.subscribe = function subscribe(fn) {\n  var subs = this._subscribers;\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn);\n  }\n  return function () {\n    var i = subs.indexOf(fn);\n    if (i > -1) {\n      subs.splice(i, 1);\n    }\n  };\n};\n\nStore.prototype.watch = function watch(getter, cb, options) {\n  var this$1 = this;\n\n  assert(typeof getter === 'function', \"store.watch only accepts a function.\");\n  return this._watcherVM.$watch(function () {\n    return getter(this$1.state, this$1.getters);\n  }, cb, options);\n};\n\nStore.prototype.replaceState = function replaceState(state) {\n  var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm._data.$$state = state;\n  });\n};\n\nStore.prototype.registerModule = function registerModule(path, rawModule) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.register(path, rawModule);\n  installModule(this, this.state, path, this._modules.get(path));\n  // reset store to update getters...\n  resetStoreVM(this, this.state);\n};\n\nStore.prototype.unregisterModule = function unregisterModule(path) {\n  var this$1 = this;\n\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\");\n  this._modules.unregister(path);\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1));\n    Vue.delete(parentState, path[path.length - 1]);\n  });\n  resetStore(this);\n};\n\nStore.prototype.hotUpdate = function hotUpdate(newOptions) {\n  this._modules.update(newOptions);\n  resetStore(this, true);\n};\n\nStore.prototype._withCommit = function _withCommit(fn) {\n  var committing = this._committing;\n  this._committing = true;\n  fn();\n  this._committing = committing;\n};\n\nObject.defineProperties(Store.prototype, prototypeAccessors);\n\nfunction resetStore(store, hot) {\n  store._actions = Object.create(null);\n  store._mutations = Object.create(null);\n  store._wrappedGetters = Object.create(null);\n  store._modulesNamespaceMap = Object.create(null);\n  var state = store.state;\n  // init all modules\n  installModule(store, state, [], store._modules.root, true);\n  // reset vm\n  resetStoreVM(store, state, hot);\n}\n\nfunction resetStoreVM(store, state, hot) {\n  var oldVm = store._vm;\n\n  // bind store public getters\n  store.getters = {};\n  var wrappedGetters = store._wrappedGetters;\n  var computed = {};\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () {\n      return fn(store);\n    };\n    Object.defineProperty(store.getters, key, {\n      get: function get() {\n        return store._vm[key];\n      },\n      enumerable: true // for local getters\n    });\n  });\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent;\n  Vue.config.silent = true;\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed: computed\n  });\n  Vue.config.silent = silent;\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store);\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(function () {\n        oldVm._data.$$state = null;\n      });\n    }\n    Vue.nextTick(function () {\n      return oldVm.$destroy();\n    });\n  }\n}\n\nfunction installModule(store, rootState, path, module, hot) {\n  var isRoot = !path.length;\n  var namespace = store._modules.getNamespace(path);\n\n  // register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module;\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1));\n    var moduleName = path[path.length - 1];\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state);\n    });\n  }\n\n  var local = module.context = makeLocalContext(store, namespace, path);\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key;\n    registerMutation(store, namespacedType, mutation, local);\n  });\n\n  module.forEachAction(function (action, key) {\n    var namespacedType = namespace + key;\n    registerAction(store, namespacedType, action, local);\n  });\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key;\n    registerGetter(store, namespacedType, getter, local);\n  });\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot);\n  });\n}\n\n/**\n * make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext(store, namespace, path) {\n  var noNamespace = namespace === '';\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._actions[type]) {\n          console.error(\"[vuex] unknown local action type: \" + args.type + \", global type: \" + type);\n          return;\n        }\n      }\n\n      return store.dispatch(type, payload);\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options);\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type;\n        if (!store._mutations[type]) {\n          console.error(\"[vuex] unknown local mutation type: \" + args.type + \", global type: \" + type);\n          return;\n        }\n      }\n\n      store.commit(type, payload, options);\n    }\n  };\n\n  // getters and state object must be gotten lazily\n  // because they will be changed by vm update\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace ? function () {\n        return store.getters;\n      } : function () {\n        return makeLocalGetters(store, namespace);\n      }\n    },\n    state: {\n      get: function get() {\n        return getNestedState(store.state, path);\n      }\n    }\n  });\n\n  return local;\n}\n\nfunction makeLocalGetters(store, namespace) {\n  var gettersProxy = {};\n\n  var splitPos = namespace.length;\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) {\n      return;\n    }\n\n    // extract local getter type\n    var localType = type.slice(splitPos);\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function get() {\n        return store.getters[type];\n      },\n      enumerable: true\n    });\n  });\n\n  return gettersProxy;\n}\n\nfunction registerMutation(store, type, handler, local) {\n  var entry = store._mutations[type] || (store._mutations[type] = []);\n  entry.push(function wrappedMutationHandler(payload) {\n    handler(local.state, payload);\n  });\n}\n\nfunction registerAction(store, type, handler, local) {\n  var entry = store._actions[type] || (store._actions[type] = []);\n  entry.push(function wrappedActionHandler(payload, cb) {\n    var res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb);\n    if (!isPromise(res)) {\n      res = Promise.resolve(res);\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err);\n        throw err;\n      });\n    } else {\n      return res;\n    }\n  });\n}\n\nfunction registerGetter(store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    console.error(\"[vuex] duplicate getter key: \" + type);\n    return;\n  }\n  store._wrappedGetters[type] = function wrappedGetter(store) {\n    return rawGetter(local.state, // local state\n    local.getters, // local getters\n    store.state, // root state\n    store.getters // root getters\n    );\n  };\n}\n\nfunction enableStrictMode(store) {\n  store._vm.$watch(function () {\n    return this._data.$$state;\n  }, function () {\n    assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\");\n  }, { deep: true, sync: true });\n}\n\nfunction getNestedState(state, path) {\n  return path.length ? path.reduce(function (state, key) {\n    return state[key];\n  }, state) : state;\n}\n\nfunction unifyObjectStyle(type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload;\n    payload = type;\n    type = type.type;\n  }\n\n  assert(typeof type === 'string', \"Expects string as the type, but found \" + (typeof type === 'undefined' ? 'undefined' : _typeof(type)) + \".\");\n\n  return { type: type, payload: payload, options: options };\n}\n\nfunction install(_Vue) {\n  if (Vue) {\n    console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');\n    return;\n  }\n  Vue = _Vue;\n  applyMixin(Vue);\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue);\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {};\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState() {\n      var state = this.$store.state;\n      var getters = this.$store.getters;\n      if (namespace) {\n        var module = getModuleByNamespace(this.$store, 'mapState', namespace);\n        if (!module) {\n          return;\n        }\n        state = module.context.state;\n        getters = module.context.getters;\n      }\n      return typeof val === 'function' ? val.call(this, state, getters) : state[val];\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res;\n});\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {};\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedMutation() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {\n        return;\n      }\n      return this.$store.commit.apply(this.$store, [val].concat(args));\n    };\n  });\n  return res;\n});\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {};\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedGetter() {\n      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {\n        return;\n      }\n      if (!(val in this.$store.getters)) {\n        console.error(\"[vuex] unknown getter: \" + val);\n        return;\n      }\n      return this.$store.getters[val];\n    };\n    // mark vuex getter for devtools\n    res[key].vuex = true;\n  });\n  return res;\n});\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {};\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val;\n    res[key] = function mappedAction() {\n      var args = [],\n          len = arguments.length;\n      while (len--) {\n        args[len] = arguments[len];\n      }if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {\n        return;\n      }\n      return this.$store.dispatch.apply(this.$store, [val].concat(args));\n    };\n  });\n  return res;\n});\n\nfunction normalizeMap(map) {\n  return Array.isArray(map) ? map.map(function (key) {\n    return { key: key, val: key };\n  }) : Object.keys(map).map(function (key) {\n    return { key: key, val: map[key] };\n  });\n}\n\nfunction normalizeNamespace(fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace;\n      namespace = '';\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/';\n    }\n    return fn(namespace, map);\n  };\n}\n\nfunction getModuleByNamespace(store, helper, namespace) {\n  var module = store._modulesNamespaceMap[namespace];\n  if (!module) {\n    console.error(\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace);\n  }\n  return module;\n}\n\nvar index_esm = {\n  Store: Store,\n  install: install,\n  version: '2.3.0',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index_esm);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLjIuMy4xQHZ1ZXgvZGlzdC92dWV4LmVzbS5qcz8wYjVkIl0sIm5hbWVzIjpbImFwcGx5TWl4aW4iLCJWdWUiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwic3BsaXQiLCJ1c2VzSW5pdCIsImNvbmZpZyIsIl9saWZlY3ljbGVIb29rcyIsImluZGV4T2YiLCJtaXhpbiIsImluaXQiLCJ2dWV4SW5pdCIsImJlZm9yZUNyZWF0ZSIsIl9pbml0IiwicHJvdG90eXBlIiwib3B0aW9ucyIsImNvbmNhdCIsImNhbGwiLCIkb3B0aW9ucyIsInN0b3JlIiwiJHN0b3JlIiwicGFyZW50IiwiZGV2dG9vbEhvb2siLCJ3aW5kb3ciLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiZGV2dG9vbFBsdWdpbiIsIl9kZXZ0b29sSG9vayIsImVtaXQiLCJvbiIsInRhcmdldFN0YXRlIiwicmVwbGFjZVN0YXRlIiwic3Vic2NyaWJlIiwibXV0YXRpb24iLCJzdGF0ZSIsImZvckVhY2hWYWx1ZSIsIm9iaiIsImZuIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpc09iamVjdCIsImlzUHJvbWlzZSIsInZhbCIsInRoZW4iLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtc2ciLCJFcnJvciIsIk1vZHVsZSIsInJhd01vZHVsZSIsInJ1bnRpbWUiLCJfY2hpbGRyZW4iLCJjcmVhdGUiLCJfcmF3TW9kdWxlIiwicmF3U3RhdGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMkMSIsIm5hbWVzcGFjZWQiLCJnZXQiLCJhZGRDaGlsZCIsIm1vZHVsZSIsInJlbW92ZUNoaWxkIiwiZ2V0Q2hpbGQiLCJ1cGRhdGUiLCJhY3Rpb25zIiwibXV0YXRpb25zIiwiZ2V0dGVycyIsImZvckVhY2hDaGlsZCIsImZvckVhY2hHZXR0ZXIiLCJmb3JFYWNoQWN0aW9uIiwiZm9yRWFjaE11dGF0aW9uIiwiZGVmaW5lUHJvcGVydGllcyIsIk1vZHVsZUNvbGxlY3Rpb24iLCJyYXdSb290TW9kdWxlIiwidGhpcyQxIiwicm9vdCIsIm1vZHVsZXMiLCJyZWdpc3RlciIsInBhdGgiLCJyZWR1Y2UiLCJnZXROYW1lc3BhY2UiLCJuYW1lc3BhY2UiLCJ1cGRhdGUkMSIsInNsaWNlIiwibmV3TW9kdWxlIiwibGVuZ3RoIiwicmF3Q2hpbGRNb2R1bGUiLCJ1bnJlZ2lzdGVyIiwidGFyZ2V0TW9kdWxlIiwiY29uc29sZSIsIndhcm4iLCJTdG9yZSIsIlByb21pc2UiLCJwbHVnaW5zIiwic3RyaWN0IiwiX2NvbW1pdHRpbmciLCJfYWN0aW9ucyIsIl9tdXRhdGlvbnMiLCJfd3JhcHBlZEdldHRlcnMiLCJfbW9kdWxlcyIsIl9tb2R1bGVzTmFtZXNwYWNlTWFwIiwiX3N1YnNjcmliZXJzIiwiX3dhdGNoZXJWTSIsInJlZiIsImRpc3BhdGNoIiwiY29tbWl0IiwiYm91bmREaXNwYXRjaCIsInR5cGUiLCJwYXlsb2FkIiwiYm91bmRDb21taXQiLCJpbnN0YWxsTW9kdWxlIiwicmVzZXRTdG9yZVZNIiwicGx1Z2luIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiX3ZtIiwiX2RhdGEiLCIkJHN0YXRlIiwic2V0IiwidiIsIl90eXBlIiwiX3BheWxvYWQiLCJfb3B0aW9ucyIsInVuaWZ5T2JqZWN0U3R5bGUiLCJlbnRyeSIsImVycm9yIiwiX3dpdGhDb21taXQiLCJjb21taXRJdGVyYXRvciIsImhhbmRsZXIiLCJzdWIiLCJzaWxlbnQiLCJhbGwiLCJtYXAiLCJzdWJzIiwicHVzaCIsImkiLCJzcGxpY2UiLCJ3YXRjaCIsImdldHRlciIsImNiIiwiJHdhdGNoIiwicmVnaXN0ZXJNb2R1bGUiLCJBcnJheSIsImlzQXJyYXkiLCJ1bnJlZ2lzdGVyTW9kdWxlIiwicGFyZW50U3RhdGUiLCJnZXROZXN0ZWRTdGF0ZSIsImRlbGV0ZSIsInJlc2V0U3RvcmUiLCJob3RVcGRhdGUiLCJuZXdPcHRpb25zIiwiY29tbWl0dGluZyIsImhvdCIsIm9sZFZtIiwid3JhcHBlZEdldHRlcnMiLCJjb21wdXRlZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImRhdGEiLCJlbmFibGVTdHJpY3RNb2RlIiwibmV4dFRpY2siLCIkZGVzdHJveSIsInJvb3RTdGF0ZSIsImlzUm9vdCIsIm1vZHVsZU5hbWUiLCJsb2NhbCIsImNvbnRleHQiLCJtYWtlTG9jYWxDb250ZXh0IiwibmFtZXNwYWNlZFR5cGUiLCJyZWdpc3Rlck11dGF0aW9uIiwiYWN0aW9uIiwicmVnaXN0ZXJBY3Rpb24iLCJyZWdpc3RlckdldHRlciIsImNoaWxkIiwibm9OYW1lc3BhY2UiLCJhcmdzIiwibWFrZUxvY2FsR2V0dGVycyIsImdldHRlcnNQcm94eSIsInNwbGl0UG9zIiwibG9jYWxUeXBlIiwid3JhcHBlZE11dGF0aW9uSGFuZGxlciIsIndyYXBwZWRBY3Rpb25IYW5kbGVyIiwicmVzIiwicm9vdEdldHRlcnMiLCJyZXNvbHZlIiwiY2F0Y2giLCJlcnIiLCJyYXdHZXR0ZXIiLCJ3cmFwcGVkR2V0dGVyIiwiZGVlcCIsInN5bmMiLCJpbnN0YWxsIiwiX1Z1ZSIsIm1hcFN0YXRlIiwibm9ybWFsaXplTmFtZXNwYWNlIiwic3RhdGVzIiwibm9ybWFsaXplTWFwIiwibWFwcGVkU3RhdGUiLCJnZXRNb2R1bGVCeU5hbWVzcGFjZSIsInZ1ZXgiLCJtYXBNdXRhdGlvbnMiLCJtYXBwZWRNdXRhdGlvbiIsImxlbiIsImFyZ3VtZW50cyIsImFwcGx5IiwibWFwR2V0dGVycyIsIm1hcHBlZEdldHRlciIsIm1hcEFjdGlvbnMiLCJtYXBwZWRBY3Rpb24iLCJjaGFyQXQiLCJoZWxwZXIiLCJpbmRleF9lc20iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7O0FBS0EsSUFBSUEsYUFBYSxTQUFiQSxVQUFhLENBQVVDLEdBQVYsRUFBZTtBQUM5QixNQUFJQyxVQUFVQyxPQUFPRixJQUFJQyxPQUFKLENBQVlFLEtBQVosQ0FBa0IsR0FBbEIsRUFBdUIsQ0FBdkIsQ0FBUCxDQUFkOztBQUVBLE1BQUlGLFdBQVcsQ0FBZixFQUFrQjtBQUNo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LEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDa0QsWUFBTWxELFNBQU47QUFDQUEsa0JBQVksRUFBWjtBQUNELEtBSEQsTUFHTyxJQUFJQSxVQUFVK0gsTUFBVixDQUFpQi9ILFVBQVVJLE1BQVYsR0FBbUIsQ0FBcEMsTUFBMkMsR0FBL0MsRUFBb0Q7QUFDekRKLG1CQUFhLEdBQWI7QUFDRDtBQUNELFdBQU83QyxHQUFHNkMsU0FBSCxFQUFja0QsR0FBZCxDQUFQO0FBQ0QsR0FSRDtBQVNEOztBQUVELFNBQVNrRSxvQkFBVCxDQUErQmxMLEtBQS9CLEVBQXNDOEwsTUFBdEMsRUFBOENoSSxTQUE5QyxFQUF5RDtBQUN2RCxNQUFJckIsU0FBU3pDLE1BQU1pRixvQkFBTixDQUEyQm5CLFNBQTNCLENBQWI7QUFDQSxNQUFJLENBQUNyQixNQUFMLEVBQWE7QUFDWDZCLFlBQVFtQyxLQUFSLENBQWUsMENBQTBDcUYsTUFBMUMsR0FBbUQsTUFBbkQsR0FBNERoSSxTQUEzRTtBQUNEO0FBQ0QsU0FBT3JCLE1BQVA7QUFDRDs7QUFFRCxJQUFJc0osWUFBWTtBQUNkdkgsU0FBT0EsS0FETztBQUVkbUcsV0FBU0EsT0FGSztBQUdkNUwsV0FBUyxPQUhLO0FBSWQ4TCxZQUFVQSxRQUpJO0FBS2RPLGdCQUFjQSxZQUxBO0FBTWRLLGNBQVlBLFVBTkU7QUFPZEUsY0FBWUE7QUFQRSxDQUFoQjs7QUFVaUUsK0RBQWVJLFNBQWYiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHZ1ZXggdjIuMy4wXG4gKiAoYykgMjAxNyBFdmFuIFlvdVxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbnZhciBhcHBseU1peGluID0gZnVuY3Rpb24gKFZ1ZSkge1xuICB2YXIgdmVyc2lvbiA9IE51bWJlcihWdWUudmVyc2lvbi5zcGxpdCgnLicpWzBdKTtcblxuICBpZiAodmVyc2lvbiA+PSAyKSB7XG4gICAgdmFyIHVzZXNJbml0ID0gVnVlLmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuaW5kZXhPZignaW5pdCcpID4gLTE7XG4gICAgVnVlLm1peGluKHVzZXNJbml0ID8geyBpbml0OiB2dWV4SW5pdCB9IDogeyBiZWZvcmVDcmVhdGU6IHZ1ZXhJbml0IH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB2YXIgX2luaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdFxuICAgICAgICA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdClcbiAgICAgICAgOiB2dWV4SW5pdDtcbiAgICAgIF9pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZ1ZXhJbml0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gc3RvcmUgaW5qZWN0aW9uXG4gICAgaWYgKG9wdGlvbnMuc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5zdG9yZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LiRzdG9yZSkge1xuICAgICAgdGhpcy4kc3RvcmUgPSBvcHRpb25zLnBhcmVudC4kc3RvcmU7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZGV2dG9vbEhvb2sgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuZnVuY3Rpb24gZGV2dG9vbFBsdWdpbiAoc3RvcmUpIHtcbiAgaWYgKCFkZXZ0b29sSG9vaykgeyByZXR1cm4gfVxuXG4gIHN0b3JlLl9kZXZ0b29sSG9vayA9IGRldnRvb2xIb29rO1xuXG4gIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6aW5pdCcsIHN0b3JlKTtcblxuICBkZXZ0b29sSG9vay5vbigndnVleDp0cmF2ZWwtdG8tc3RhdGUnLCBmdW5jdGlvbiAodGFyZ2V0U3RhdGUpIHtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUodGFyZ2V0U3RhdGUpO1xuICB9KTtcblxuICBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKG11dGF0aW9uLCBzdGF0ZSkge1xuICAgIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6bXV0YXRpb24nLCBtdXRhdGlvbiwgc3RhdGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGl0ZW0gdGhhdCBwYXNzIHRoZSB0ZXN0XG4gKiBieSBzZWNvbmQgYXJndW1lbnQgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcmV0dXJuIHsqfVxuICovXG4vKipcbiAqIERlZXAgY29weSB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnNpZGVyaW5nIGNpcmN1bGFyIHN0cnVjdHVyZS5cbiAqIFRoaXMgZnVuY3Rpb24gY2FjaGVzIGFsbCBuZXN0ZWQgb2JqZWN0cyBhbmQgaXRzIGNvcGllcy5cbiAqIElmIGl0IGRldGVjdHMgY2lyY3VsYXIgc3RydWN0dXJlLCB1c2UgY2FjaGVkIGNvcHkgdG8gYXZvaWQgaW5maW5pdGUgbG9vcC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBjYWNoZVxuICogQHJldHVybiB7Kn1cbiAqL1xuXG5cbi8qKlxuICogZm9yRWFjaCBmb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hWYWx1ZSAob2JqLCBmbikge1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4ob2JqW2tleV0sIGtleSk7IH0pO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbidcbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1zZykge1xuICBpZiAoIWNvbmRpdGlvbikgeyB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZXhdIFwiICsgbXNnKSkgfVxufVxuXG52YXIgTW9kdWxlID0gZnVuY3Rpb24gTW9kdWxlIChyYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgdGhpcy5fY2hpbGRyZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9yYXdNb2R1bGUgPSByYXdNb2R1bGU7XG4gIHZhciByYXdTdGF0ZSA9IHJhd01vZHVsZS5zdGF0ZTtcbiAgdGhpcy5zdGF0ZSA9ICh0eXBlb2YgcmF3U3RhdGUgPT09ICdmdW5jdGlvbicgPyByYXdTdGF0ZSgpIDogcmF3U3RhdGUpIHx8IHt9O1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyQxID0geyBuYW1lc3BhY2VkOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMkMS5uYW1lc3BhY2VkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWRcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZCAoa2V5LCBtb2R1bGUpIHtcbiAgdGhpcy5fY2hpbGRyZW5ba2V5XSA9IG1vZHVsZTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoa2V5KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltrZXldO1xufTtcblxuTW9kdWxlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuW2tleV1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChyYXdNb2R1bGUpIHtcbiAgdGhpcy5fcmF3TW9kdWxlLm5hbWVzcGFjZWQgPSByYXdNb2R1bGUubmFtZXNwYWNlZDtcbiAgaWYgKHJhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMgPSByYXdNb2R1bGUuYWN0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMgPSByYXdNb2R1bGUubXV0YXRpb25zO1xuICB9XG4gIGlmIChyYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5nZXR0ZXJzID0gcmF3TW9kdWxlLmdldHRlcnM7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gZm9yRWFjaENoaWxkIChmbikge1xuICBmb3JFYWNoVmFsdWUodGhpcy5fY2hpbGRyZW4sIGZuKTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEdldHRlciA9IGZ1bmN0aW9uIGZvckVhY2hHZXR0ZXIgKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycywgZm4pO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hBY3Rpb24gPSBmdW5jdGlvbiBmb3JFYWNoQWN0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmFjdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoTXV0YXRpb24gPSBmdW5jdGlvbiBmb3JFYWNoTXV0YXRpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMsIGZuKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1vZHVsZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJvb3QgPSBuZXcgTW9kdWxlKHJhd1Jvb3RNb2R1bGUsIGZhbHNlKTtcblxuICAvLyByZWdpc3RlciBhbGwgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd1Jvb3RNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdSb290TW9kdWxlLm1vZHVsZXMsIGZ1bmN0aW9uIChyYXdNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKFtrZXldLCByYXdNb2R1bGUsIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobW9kdWxlLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlLmdldENoaWxkKGtleSlcbiAgfSwgdGhpcy5yb290KVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gZ2V0TmFtZXNwYWNlIChwYXRoKSB7XG4gIHZhciBtb2R1bGUgPSB0aGlzLnJvb3Q7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBrZXkpIHtcbiAgICBtb2R1bGUgPSBtb2R1bGUuZ2V0Q2hpbGQoa2V5KTtcbiAgICByZXR1cm4gbmFtZXNwYWNlICsgKG1vZHVsZS5uYW1lc3BhY2VkID8ga2V5ICsgJy8nIDogJycpXG4gIH0sICcnKVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlJDEgKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdXBkYXRlKHRoaXMucm9vdCwgcmF3Um9vdE1vZHVsZSk7XG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHJ1bnRpbWUgPT09IHZvaWQgMCApIHJ1bnRpbWUgPSB0cnVlO1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBuZXdNb2R1bGUgPSBuZXcgTW9kdWxlKHJhd01vZHVsZSwgcnVudGltZSk7XG4gIHBhcmVudC5hZGRDaGlsZChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIG5ld01vZHVsZSk7XG5cbiAgLy8gcmVnaXN0ZXIgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3Q2hpbGRNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKHBhdGguY29uY2F0KGtleSksIHJhd0NoaWxkTW9kdWxlLCBydW50aW1lKTtcbiAgICB9KTtcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIgKHBhdGgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0KHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgaWYgKCFwYXJlbnQuZ2V0Q2hpbGQoa2V5KS5ydW50aW1lKSB7IHJldHVybiB9XG5cbiAgcGFyZW50LnJlbW92ZUNoaWxkKGtleSk7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGUgKHRhcmdldE1vZHVsZSwgbmV3TW9kdWxlKSB7XG4gIC8vIHVwZGF0ZSB0YXJnZXQgbW9kdWxlXG4gIHRhcmdldE1vZHVsZS51cGRhdGUobmV3TW9kdWxlKTtcblxuICAvLyB1cGRhdGUgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgICBpZiAoIXRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gYWRkIGEgbmV3IG1vZHVsZSAnXCIgKyBrZXkgKyBcIicgb24gaG90IHJlbG9hZGluZywgXCIgK1xuICAgICAgICAgICdtYW51YWwgcmVsb2FkIGlzIG5lZWRlZCdcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUodGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSksIG5ld01vZHVsZS5tb2R1bGVzW2tleV0pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgVnVlOyAvLyBiaW5kIG9uIGluc3RhbGxcblxudmFyIFN0b3JlID0gZnVuY3Rpb24gU3RvcmUgKG9wdGlvbnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGFzc2VydChWdWUsIFwibXVzdCBjYWxsIFZ1ZS51c2UoVnVleCkgYmVmb3JlIGNyZWF0aW5nIGEgc3RvcmUgaW5zdGFuY2UuXCIpO1xuICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG5cbiAgdmFyIHN0YXRlID0gb3B0aW9ucy5zdGF0ZTsgaWYgKCBzdGF0ZSA9PT0gdm9pZCAwICkgc3RhdGUgPSB7fTtcbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcblxuICAvLyBzdG9yZSBpbnRlcm5hbCBzdGF0ZVxuICB0aGlzLl9jb21taXR0aW5nID0gZmFsc2U7XG4gIHRoaXMuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX21vZHVsZXMgPSBuZXcgTW9kdWxlQ29sbGVjdGlvbihvcHRpb25zKTtcbiAgdGhpcy5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG4gIHRoaXMuX3dhdGNoZXJWTSA9IG5ldyBWdWUoKTtcblxuICAvLyBiaW5kIGNvbW1pdCBhbmQgZGlzcGF0Y2ggdG8gc2VsZlxuICB2YXIgc3RvcmUgPSB0aGlzO1xuICB2YXIgcmVmID0gdGhpcztcbiAgdmFyIGRpc3BhdGNoID0gcmVmLmRpc3BhdGNoO1xuICB2YXIgY29tbWl0ID0gcmVmLmNvbW1pdDtcbiAgdGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uIGJvdW5kRGlzcGF0Y2ggKHR5cGUsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2guY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZClcbiAgfTtcbiAgdGhpcy5jb21taXQgPSBmdW5jdGlvbiBib3VuZENvbW1pdCAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBjb21taXQuY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZCwgb3B0aW9ucylcbiAgfTtcblxuICAvLyBzdHJpY3QgbW9kZVxuICB0aGlzLnN0cmljdCA9IHN0cmljdDtcblxuICAvLyBpbml0IHJvb3QgbW9kdWxlLlxuICAvLyB0aGlzIGFsc28gcmVjdXJzaXZlbHkgcmVnaXN0ZXJzIGFsbCBzdWItbW9kdWxlc1xuICAvLyBhbmQgY29sbGVjdHMgYWxsIG1vZHVsZSBnZXR0ZXJzIGluc2lkZSB0aGlzLl93cmFwcGVkR2V0dGVyc1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHN0YXRlLCBbXSwgdGhpcy5fbW9kdWxlcy5yb290KTtcblxuICAvLyBpbml0aWFsaXplIHRoZSBzdG9yZSB2bSwgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIHRoZSByZWFjdGl2aXR5XG4gIC8vIChhbHNvIHJlZ2lzdGVycyBfd3JhcHBlZEdldHRlcnMgYXMgY29tcHV0ZWQgcHJvcGVydGllcylcbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHN0YXRlKTtcblxuICAvLyBhcHBseSBwbHVnaW5zXG4gIHBsdWdpbnMuY29uY2F0KGRldnRvb2xQbHVnaW4pLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKHRoaXMkMSk7IH0pO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc3RhdGU6IHt9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl92bS5fZGF0YS4kJHN0YXRlXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuc2V0ID0gZnVuY3Rpb24gKHYpIHtcbiAgYXNzZXJ0KGZhbHNlLCBcIlVzZSBzdG9yZS5yZXBsYWNlU3RhdGUoKSB0byBleHBsaWNpdCByZXBsYWNlIHN0b3JlIHN0YXRlLlwiKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiBjb21taXQgKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgY29tbWl0XG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gIHZhciBtdXRhdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIG11dGF0aW9uIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgIHJldHVyblxuICB9XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIGVudHJ5LmZvckVhY2goZnVuY3Rpb24gY29tbWl0SXRlcmF0b3IgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIocGF5bG9hZCk7XG4gICAgfSk7XG4gIH0pO1xuICB0aGlzLl9zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1YihtdXRhdGlvbiwgdGhpcyQxLnN0YXRlKTsgfSk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlt2dWV4XSBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUgKyBcIi4gU2lsZW50IG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBcIiArXG4gICAgICAnVXNlIHRoZSBmaWx0ZXIgZnVuY3Rpb25hbGl0eSBpbiB0aGUgdnVlLWRldnRvb2xzJ1xuICAgICk7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoIChfdHlwZSwgX3BheWxvYWQpIHtcbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGRpc3BhdGNoXG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgcGF5bG9hZCA9IHJlZi5wYXlsb2FkO1xuXG4gIHZhciBlbnRyeSA9IHRoaXMuX2FjdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChmbikge1xuICB2YXIgc3VicyA9IHRoaXMuX3N1YnNjcmliZXJzO1xuICBpZiAoc3Vicy5pbmRleE9mKGZuKSA8IDApIHtcbiAgICBzdWJzLnB1c2goZm4pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBzdWJzLmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gd2F0Y2ggKGdldHRlciwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBhc3NlcnQodHlwZW9mIGdldHRlciA9PT0gJ2Z1bmN0aW9uJywgXCJzdG9yZS53YXRjaCBvbmx5IGFjY2VwdHMgYSBmdW5jdGlvbi5cIik7XG4gIHJldHVybiB0aGlzLl93YXRjaGVyVk0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldHRlcih0aGlzJDEuc3RhdGUsIHRoaXMkMS5nZXR0ZXJzKTsgfSwgY2IsIG9wdGlvbnMpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlIChzdGF0ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS5fdm0uX2RhdGEuJCRzdGF0ZSA9IHN0YXRlO1xuICB9KTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlIChwYXRoLCByYXdNb2R1bGUpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCkpO1xuICAvLyByZXNldCBzdG9yZSB0byB1cGRhdGUgZ2V0dGVycy4uLlxuICByZXNldFN0b3JlVk0odGhpcywgdGhpcy5zdGF0ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUudW5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJNb2R1bGUgKHBhdGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gIHRoaXMuX21vZHVsZXMudW5yZWdpc3RlcihwYXRoKTtcbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUodGhpcyQxLnN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgVnVlLmRlbGV0ZShwYXJlbnRTdGF0ZSwgcGF0aFtwYXRoLmxlbmd0aCAtIDFdKTtcbiAgfSk7XG4gIHJlc2V0U3RvcmUodGhpcyk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuaG90VXBkYXRlID0gZnVuY3Rpb24gaG90VXBkYXRlIChuZXdPcHRpb25zKSB7XG4gIHRoaXMuX21vZHVsZXMudXBkYXRlKG5ld09wdGlvbnMpO1xuICByZXNldFN0b3JlKHRoaXMsIHRydWUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLl93aXRoQ29tbWl0ID0gZnVuY3Rpb24gX3dpdGhDb21taXQgKGZuKSB7XG4gIHZhciBjb21taXR0aW5nID0gdGhpcy5fY29tbWl0dGluZztcbiAgdGhpcy5fY29tbWl0dGluZyA9IHRydWU7XG4gIGZuKCk7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBjb21taXR0aW5nO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFN0b3JlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbmZ1bmN0aW9uIHJlc2V0U3RvcmUgKHN0b3JlLCBob3QpIHtcbiAgc3RvcmUuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX3dyYXBwZWRHZXR0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgc3RhdGUgPSBzdG9yZS5zdGF0ZTtcbiAgLy8gaW5pdCBhbGwgbW9kdWxlc1xuICBpbnN0YWxsTW9kdWxlKHN0b3JlLCBzdGF0ZSwgW10sIHN0b3JlLl9tb2R1bGVzLnJvb3QsIHRydWUpO1xuICAvLyByZXNldCB2bVxuICByZXNldFN0b3JlVk0oc3RvcmUsIHN0YXRlLCBob3QpO1xufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlVk0gKHN0b3JlLCBzdGF0ZSwgaG90KSB7XG4gIHZhciBvbGRWbSA9IHN0b3JlLl92bTtcblxuICAvLyBiaW5kIHN0b3JlIHB1YmxpYyBnZXR0ZXJzXG4gIHN0b3JlLmdldHRlcnMgPSB7fTtcbiAgdmFyIHdyYXBwZWRHZXR0ZXJzID0gc3RvcmUuX3dyYXBwZWRHZXR0ZXJzO1xuICB2YXIgY29tcHV0ZWQgPSB7fTtcbiAgZm9yRWFjaFZhbHVlKHdyYXBwZWRHZXR0ZXJzLCBmdW5jdGlvbiAoZm4sIGtleSkge1xuICAgIC8vIHVzZSBjb21wdXRlZCB0byBsZXZlcmFnZSBpdHMgbGF6eS1jYWNoaW5nIG1lY2hhbmlzbVxuICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmbihzdG9yZSk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0b3JlLmdldHRlcnMsIGtleSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5fdm1ba2V5XTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUgLy8gZm9yIGxvY2FsIGdldHRlcnNcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gIC8vIHN1cHByZXNzIHdhcm5pbmdzIGp1c3QgaW4gY2FzZSB0aGUgdXNlciBoYXMgYWRkZWRcbiAgLy8gc29tZSBmdW5reSBnbG9iYWwgbWl4aW5zXG4gIHZhciBzaWxlbnQgPSBWdWUuY29uZmlnLnNpbGVudDtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSB0cnVlO1xuICBzdG9yZS5fdm0gPSBuZXcgVnVlKHtcbiAgICBkYXRhOiB7XG4gICAgICAkJHN0YXRlOiBzdGF0ZVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkXG4gIH0pO1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHNpbGVudDtcblxuICAvLyBlbmFibGUgc3RyaWN0IG1vZGUgZm9yIG5ldyB2bVxuICBpZiAoc3RvcmUuc3RyaWN0KSB7XG4gICAgZW5hYmxlU3RyaWN0TW9kZShzdG9yZSk7XG4gIH1cblxuICBpZiAob2xkVm0pIHtcbiAgICBpZiAoaG90KSB7XG4gICAgICAvLyBkaXNwYXRjaCBjaGFuZ2VzIGluIGFsbCBzdWJzY3JpYmVkIHdhdGNoZXJzXG4gICAgICAvLyB0byBmb3JjZSBnZXR0ZXIgcmUtZXZhbHVhdGlvbiBmb3IgaG90IHJlbG9hZGluZy5cbiAgICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2xkVm0uX2RhdGEuJCRzdGF0ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9sZFZtLiRkZXN0cm95KCk7IH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNb2R1bGUgKHN0b3JlLCByb290U3RhdGUsIHBhdGgsIG1vZHVsZSwgaG90KSB7XG4gIHZhciBpc1Jvb3QgPSAhcGF0aC5sZW5ndGg7XG4gIHZhciBuYW1lc3BhY2UgPSBzdG9yZS5fbW9kdWxlcy5nZXROYW1lc3BhY2UocGF0aCk7XG5cbiAgLy8gcmVnaXN0ZXIgaW4gbmFtZXNwYWNlIG1hcFxuICBpZiAobW9kdWxlLm5hbWVzcGFjZWQpIHtcbiAgICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcFtuYW1lc3BhY2VdID0gbW9kdWxlO1xuICB9XG5cbiAgLy8gc2V0IHN0YXRlXG4gIGlmICghaXNSb290ICYmICFob3QpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZShyb290U3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICB2YXIgbW9kdWxlTmFtZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICBWdWUuc2V0KHBhcmVudFN0YXRlLCBtb2R1bGVOYW1lLCBtb2R1bGUuc3RhdGUpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGxvY2FsID0gbW9kdWxlLmNvbnRleHQgPSBtYWtlTG9jYWxDb250ZXh0KHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpO1xuXG4gIG1vZHVsZS5mb3JFYWNoTXV0YXRpb24oZnVuY3Rpb24gKG11dGF0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIG11dGF0aW9uLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQWN0aW9uKGZ1bmN0aW9uIChhY3Rpb24sIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3RlckFjdGlvbihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIGFjdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEdldHRlcihmdW5jdGlvbiAoZ2V0dGVyLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJHZXR0ZXIoc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBnZXR0ZXIsIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQsIGtleSkge1xuICAgIGluc3RhbGxNb2R1bGUoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aC5jb25jYXQoa2V5KSwgY2hpbGQsIGhvdCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIG1ha2UgbG9jYWxpemVkIGRpc3BhdGNoLCBjb21taXQsIGdldHRlcnMgYW5kIHN0YXRlXG4gKiBpZiB0aGVyZSBpcyBubyBuYW1lc3BhY2UsIGp1c3QgdXNlIHJvb3Qgb25lc1xuICovXG5mdW5jdGlvbiBtYWtlTG9jYWxDb250ZXh0IChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKSB7XG4gIHZhciBub05hbWVzcGFjZSA9IG5hbWVzcGFjZSA9PT0gJyc7XG5cbiAgdmFyIGxvY2FsID0ge1xuICAgIGRpc3BhdGNoOiBub05hbWVzcGFjZSA/IHN0b3JlLmRpc3BhdGNoIDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGU7XG4gICAgICAgIGlmICghc3RvcmUuX2FjdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIGFjdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2godHlwZSwgcGF5bG9hZClcbiAgICB9LFxuXG4gICAgY29tbWl0OiBub05hbWVzcGFjZSA/IHN0b3JlLmNvbW1pdCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoIXN0b3JlLl9tdXRhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIG11dGF0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmNvbW1pdCh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0dGVycyBhbmQgc3RhdGUgb2JqZWN0IG11c3QgYmUgZ290dGVuIGxhemlseVxuICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBjaGFuZ2VkIGJ5IHZtIHVwZGF0ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsb2NhbCwge1xuICAgIGdldHRlcnM6IHtcbiAgICAgIGdldDogbm9OYW1lc3BhY2VcbiAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbmFtZXNwYWNlKTsgfVxuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TmVzdGVkU3RhdGUoc3RvcmUuc3RhdGUsIHBhdGgpOyB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbG9jYWxcbn1cblxuZnVuY3Rpb24gbWFrZUxvY2FsR2V0dGVycyAoc3RvcmUsIG5hbWVzcGFjZSkge1xuICB2YXIgZ2V0dGVyc1Byb3h5ID0ge307XG5cbiAgdmFyIHNwbGl0UG9zID0gbmFtZXNwYWNlLmxlbmd0aDtcbiAgT2JqZWN0LmtleXMoc3RvcmUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIHNraXAgaWYgdGhlIHRhcmdldCBnZXR0ZXIgaXMgbm90IG1hdGNoIHRoaXMgbmFtZXNwYWNlXG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgc3BsaXRQb3MpICE9PSBuYW1lc3BhY2UpIHsgcmV0dXJuIH1cblxuICAgIC8vIGV4dHJhY3QgbG9jYWwgZ2V0dGVyIHR5cGVcbiAgICB2YXIgbG9jYWxUeXBlID0gdHlwZS5zbGljZShzcGxpdFBvcyk7XG5cbiAgICAvLyBBZGQgYSBwb3J0IHRvIHRoZSBnZXR0ZXJzIHByb3h5LlxuICAgIC8vIERlZmluZSBhcyBnZXR0ZXIgcHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV2YWx1YXRlIHRoZSBnZXR0ZXJzIGluIHRoaXMgdGltZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0dGVyc1Byb3h5LCBsb2NhbFR5cGUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyc1t0eXBlXTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGdldHRlcnNQcm94eVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX211dGF0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX211dGF0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkTXV0YXRpb25IYW5kbGVyIChwYXlsb2FkKSB7XG4gICAgaGFuZGxlcihsb2NhbC5zdGF0ZSwgcGF5bG9hZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9hY3Rpb25zW3R5cGVdIHx8IChzdG9yZS5fYWN0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkQWN0aW9uSGFuZGxlciAocGF5bG9hZCwgY2IpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlcih7XG4gICAgICBkaXNwYXRjaDogbG9jYWwuZGlzcGF0Y2gsXG4gICAgICBjb21taXQ6IGxvY2FsLmNvbW1pdCxcbiAgICAgIGdldHRlcnM6IGxvY2FsLmdldHRlcnMsXG4gICAgICBzdGF0ZTogbG9jYWwuc3RhdGUsXG4gICAgICByb290R2V0dGVyczogc3RvcmUuZ2V0dGVycyxcbiAgICAgIHJvb3RTdGF0ZTogc3RvcmUuc3RhdGVcbiAgICB9LCBwYXlsb2FkLCBjYik7XG4gICAgaWYgKCFpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzID0gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgfVxuICAgIGlmIChzdG9yZS5fZGV2dG9vbEhvb2spIHtcbiAgICAgIHJldHVybiByZXMuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzdG9yZS5fZGV2dG9vbEhvb2suZW1pdCgndnVleDplcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR2V0dGVyIChzdG9yZSwgdHlwZSwgcmF3R2V0dGVyLCBsb2NhbCkge1xuICBpZiAoc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gZHVwbGljYXRlIGdldHRlciBrZXk6IFwiICsgdHlwZSkpO1xuICAgIHJldHVyblxuICB9XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSA9IGZ1bmN0aW9uIHdyYXBwZWRHZXR0ZXIgKHN0b3JlKSB7XG4gICAgcmV0dXJuIHJhd0dldHRlcihcbiAgICAgIGxvY2FsLnN0YXRlLCAvLyBsb2NhbCBzdGF0ZVxuICAgICAgbG9jYWwuZ2V0dGVycywgLy8gbG9jYWwgZ2V0dGVyc1xuICAgICAgc3RvcmUuc3RhdGUsIC8vIHJvb3Qgc3RhdGVcbiAgICAgIHN0b3JlLmdldHRlcnMgLy8gcm9vdCBnZXR0ZXJzXG4gICAgKVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmFibGVTdHJpY3RNb2RlIChzdG9yZSkge1xuICBzdG9yZS5fdm0uJHdhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEuJCRzdGF0ZSB9LCBmdW5jdGlvbiAoKSB7XG4gICAgYXNzZXJ0KHN0b3JlLl9jb21taXR0aW5nLCBcIkRvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLlwiKTtcbiAgfSwgeyBkZWVwOiB0cnVlLCBzeW5jOiB0cnVlIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROZXN0ZWRTdGF0ZSAoc3RhdGUsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoXG4gICAgPyBwYXRoLnJlZHVjZShmdW5jdGlvbiAoc3RhdGUsIGtleSkgeyByZXR1cm4gc3RhdGVba2V5XTsgfSwgc3RhdGUpXG4gICAgOiBzdGF0ZVxufVxuXG5mdW5jdGlvbiB1bmlmeU9iamVjdFN0eWxlICh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gIGlmIChpc09iamVjdCh0eXBlKSAmJiB0eXBlLnR5cGUpIHtcbiAgICBvcHRpb25zID0gcGF5bG9hZDtcbiAgICBwYXlsb2FkID0gdHlwZTtcbiAgICB0eXBlID0gdHlwZS50eXBlO1xuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgKFwiRXhwZWN0cyBzdHJpbmcgYXMgdGhlIHR5cGUsIGJ1dCBmb3VuZCBcIiArICh0eXBlb2YgdHlwZSkgKyBcIi5cIikpO1xuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQsIG9wdGlvbnM6IG9wdGlvbnMgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsIChfVnVlKSB7XG4gIGlmIChWdWUpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ1t2dWV4XSBhbHJlYWR5IGluc3RhbGxlZC4gVnVlLnVzZShWdWV4KSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBWdWUgPSBfVnVlO1xuICBhcHBseU1peGluKFZ1ZSk7XG59XG5cbi8vIGF1dG8gaW5zdGFsbCBpbiBkaXN0IG1vZGVcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gIGluc3RhbGwod2luZG93LlZ1ZSk7XG59XG5cbnZhciBtYXBTdGF0ZSA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBzdGF0ZXMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoc3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkU3RhdGUgKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGU7XG4gICAgICB2YXIgZ2V0dGVycyA9IHRoaXMuJHN0b3JlLmdldHRlcnM7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcFN0YXRlJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IG1vZHVsZS5jb250ZXh0LnN0YXRlO1xuICAgICAgICBnZXR0ZXJzID0gbW9kdWxlLmNvbnRleHQuZ2V0dGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmNhbGwodGhpcywgc3RhdGUsIGdldHRlcnMpXG4gICAgICAgIDogc3RhdGVbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwTXV0YXRpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIG11dGF0aW9ucykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChtdXRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkTXV0YXRpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwTXV0YXRpb25zJywgbmFtZXNwYWNlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5jb21taXQuYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBtYXBHZXR0ZXJzID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGdldHRlcnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICB2YWwgPSBuYW1lc3BhY2UgKyB2YWw7XG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRHZXR0ZXIgKCkge1xuICAgICAgaWYgKG5hbWVzcGFjZSAmJiAhZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBHZXR0ZXJzJywgbmFtZXNwYWNlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghKHZhbCBpbiB0aGlzLiRzdG9yZS5nZXR0ZXJzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGdldHRlcjogXCIgKyB2YWwpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1t2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBtYXBBY3Rpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGFjdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICB2YWwgPSBuYW1lc3BhY2UgKyB2YWw7XG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRBY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwQWN0aW9ucycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZGlzcGF0Y2guYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1hcCAobWFwKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1hcClcbiAgICA/IG1hcC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDoga2V5IH0pOyB9KVxuICAgIDogT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDogbWFwW2tleV0gfSk7IH0pXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWVzcGFjZSAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1hcCkge1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgbWFwID0gbmFtZXNwYWNlO1xuICAgICAgbmFtZXNwYWNlID0gJyc7XG4gICAgfSBlbHNlIGlmIChuYW1lc3BhY2UuY2hhckF0KG5hbWVzcGFjZS5sZW5ndGggLSAxKSAhPT0gJy8nKSB7XG4gICAgICBuYW1lc3BhY2UgKz0gJy8nO1xuICAgIH1cbiAgICByZXR1cm4gZm4obmFtZXNwYWNlLCBtYXApXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlQnlOYW1lc3BhY2UgKHN0b3JlLCBoZWxwZXIsIG5hbWVzcGFjZSkge1xuICB2YXIgbW9kdWxlID0gc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXTtcbiAgaWYgKCFtb2R1bGUpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBtb2R1bGUgbmFtZXNwYWNlIG5vdCBmb3VuZCBpbiBcIiArIGhlbHBlciArIFwiKCk6IFwiICsgbmFtZXNwYWNlKSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZVxufVxuXG52YXIgaW5kZXhfZXNtID0ge1xuICBTdG9yZTogU3RvcmUsXG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICcyLjMuMCcsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMsXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMsXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnNcbn07XG5cbmV4cG9ydCB7IFN0b3JlLCBtYXBTdGF0ZSwgbWFwTXV0YXRpb25zLCBtYXBHZXR0ZXJzLCBtYXBBY3Rpb25zIH07ZXhwb3J0IGRlZmF1bHQgaW5kZXhfZXNtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzLy4yLjMuMUB2dWV4L2Rpc3QvdnVleC5lc20uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),

/***/ 16:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(process) {var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n  * vue-router v2.7.0\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(\"[vue-router] \" + message);\n  }\n}\n\nfunction warn(condition, message) {\n  if (process.env.NODE_ENV !== 'production' && !condition) {\n    typeof console !== 'undefined' && console.warn(\"[vue-router] \" + message);\n  }\n}\n\nfunction isError(err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1;\n}\n\nvar View = {\n  name: 'router-view',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render(_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      if (parent.$vnode && parent.$vnode.data.routerView) {\n        depth++;\n      }\n      if (parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      return h(cache[name], data, children);\n    }\n\n    var matched = route.matched[depth];\n    // render empty node if no matched route\n    if (!matched) {\n      cache[name] = null;\n      return h();\n    }\n\n    var component = cache[name] = matched.components[name];\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (val && current !== vm || !val && current === vm) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also regiseter instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // resolve props\n    data.props = resolveProps(route, matched.props && matched.props[name]);\n\n    return h(component, data, children);\n  }\n};\n\nfunction resolveProps(route, config) {\n  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {\n    case 'undefined':\n      return;\n    case 'object':\n      return config;\n    case 'function':\n      return config(route);\n    case 'boolean':\n      return config ? route.params : undefined;\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"props in \\\"\" + route.path + \"\\\" is a \" + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + \", \" + \"expecting an object, function or boolean.\");\n      }\n  }\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n};\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function encode(str) {\n  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');\n};\n\nvar decode = decodeURIComponent;\n\nfunction resolveQuery(query, extraQuery, _parseQuery) {\n  if (extraQuery === void 0) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n    process.env.NODE_ENV !== 'production' && warn(false, e.message);\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    var val = extraQuery[key];\n    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;\n  }\n  return parsedQuery;\n}\n\nfunction parseQuery(query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res;\n}\n\nfunction stringifyQuery(obj) {\n  var res = obj ? Object.keys(obj).map(function (key) {\n    var val = obj[key];\n\n    if (val === undefined) {\n      return '';\n    }\n\n    if (val === null) {\n      return encode(key);\n    }\n\n    if (Array.isArray(val)) {\n      var result = [];\n      val.forEach(function (val2) {\n        if (val2 === undefined) {\n          return;\n        }\n        if (val2 === null) {\n          result.push(encode(key));\n        } else {\n          result.push(encode(key) + '=' + encode(val2));\n        }\n      });\n      return result.join('&');\n    }\n\n    return encode(key) + '=' + encode(val);\n  }).filter(function (x) {\n    return x.length > 0;\n  }).join('&') : null;\n  return res ? \"?\" + res : '';\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute(record, location, redirectedFrom, router) {\n  var stringifyQuery$$1 = router && router.options.stringifyQuery;\n  var route = {\n    name: location.name || record && record.name,\n    meta: record && record.meta || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: location.query || {},\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery$$1),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n  }\n  return Object.freeze(route);\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch(record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res;\n}\n\nfunction getFullPath(ref, _stringifyQuery) {\n  var path = ref.path;\n  var query = ref.query;if (query === void 0) query = {};\n  var hash = ref.hash;if (hash === void 0) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash;\n}\n\nfunction isSameRoute(a, b) {\n  if (b === START) {\n    return a === b;\n  } else if (!b) {\n    return false;\n  } else if (a.path && b.path) {\n    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);\n  } else if (a.name && b.name) {\n    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);\n  } else {\n    return false;\n  }\n}\n\nfunction isObjectEqual(a, b) {\n  if (a === void 0) a = {};\n  if (b === void 0) b = {};\n\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n  return aKeys.every(function (key) {\n    var aVal = a[key];\n    var bVal = b[key];\n    // check nested equality\n    if ((typeof aVal === 'undefined' ? 'undefined' : _typeof(aVal)) === 'object' && (typeof bVal === 'undefined' ? 'undefined' : _typeof(bVal)) === 'object') {\n      return isObjectEqual(aVal, bVal);\n    }\n    return String(aVal) === String(bVal);\n  });\n}\n\nfunction isIncludedRoute(current, target) {\n  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);\n}\n\nfunction queryIncludes(current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar Link = {\n  name: 'router-link',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    exact: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render(h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(this.to, current, this.append);\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;\n    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;\n    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;\n    var compareTarget = location.path ? createRoute(null, location, null, router) : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget);\n    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);\n\n    var handler = function handler(e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location);\n        } else {\n          router.push(location);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) {\n        on[e] = handler;\n      });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = {\n      class: classes\n    };\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var extend = _Vue.util.extend;\n        var aData = a.data = extend({}, a.data);\n        aData.on = on;\n        var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n        aAttrs.href = href;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default);\n  }\n};\n\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {\n    return;\n  }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) {\n    return;\n  }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) {\n    return;\n  }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) {\n      return;\n    }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true;\n}\n\nfunction findAnchor(children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child;\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child;\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install(Vue) {\n  if (install.installed) {\n    return;\n  }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function isDef(v) {\n    return v !== undefined;\n  };\n\n  var registerInstance = function registerInstance(vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate() {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = this.$parent && this.$parent._routerRoot || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed() {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get() {\n      return this._routerRoot._router;\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get() {\n      return this._routerRoot._route;\n    }\n  });\n\n  Vue.component('router-view', View);\n  Vue.component('router-link', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction resolvePath(relative, base, append) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative;\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative;\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/');\n}\n\nfunction parsePath(path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction cleanPath(path) {\n  return path.replace(/\\/\\//g, '/');\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)',\n// Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options));\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (_typeof(tokens[i]) === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (index$1(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags(options) {\n  return options.sensitive ? '' : 'i';\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys);\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp(path, keys, options) {\n  if (!index$1(keys)) {\n    options = /** @type {!Object} */keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */keys);\n  }\n\n  if (index$1(path)) {\n    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);\n  }\n\n  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams(path, params, routeMsg) {\n  try {\n    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));\n    return filler(params || {}, { pretty: true });\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"missing param for \" + routeMsg + \": \" + e.message);\n    }\n    return '';\n  }\n}\n\n/*  */\n\nfunction createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  var pathMap = oldPathMap || Object.create(null);\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  };\n}\n\nfunction addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {\n  var path = route.path;\n  var name = route.name;\n  if (process.env.NODE_ENV !== 'production') {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(typeof route.component !== 'string', \"route config \\\"component\\\" for path: \" + String(path || name) + \" cannot be a \" + \"string id. Use an actual component instead.\");\n  }\n\n  var normalizedPath = normalizePath(path, parent);\n  var pathToRegexpOptions = route.pathToRegexpOptions || {};\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    instances: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props: route.props == null ? {} : route.components ? route.props : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (process.env.NODE_ENV !== 'production') {\n      if (route.name && !route.redirect && route.children.some(function (child) {\n        return (/^\\/?$/.test(child.path)\n        );\n      })) {\n        warn(false, \"Named Route '\" + route.name + \"' has a default child route. \" + \"When navigating to this named route (:to=\\\"{name: '\" + route.name + \"'\\\"), \" + \"the default child route will not be rendered. Remove the name from \" + \"this route and use the name of the default child route for named \" + \"links instead.\");\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs ? cleanPath(matchAs + \"/\" + child.path) : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n\n    aliases.forEach(function (alias) {\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs\n      );\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {\n      warn(false, \"Duplicate named routes definition: \" + \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + record.path + \"\\\" }\");\n    }\n  }\n}\n\nfunction compileRouteRegex(path, pathToRegexpOptions) {\n  var regex = index(path, [], pathToRegexpOptions);\n  if (process.env.NODE_ENV !== 'production') {\n    var keys = {};\n    regex.keys.forEach(function (key) {\n      warn(!keys[key.name], \"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\");\n      keys[key.name] = true;\n    });\n  }\n  return regex;\n}\n\nfunction normalizePath(path, parent) {\n  path = path.replace(/\\/$/, '');\n  if (path[0] === '/') {\n    return path;\n  }\n  if (parent == null) {\n    return path;\n  }\n  return cleanPath(parent.path + \"/\" + path);\n}\n\n/*  */\n\nfunction normalizeLocation(raw, current, append, router) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next.name || next._normalized) {\n    return next;\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = assign({}, next);\n    next._normalized = true;\n    var params = assign(assign({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params, \"path \" + current.path);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next;\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = current && current.path || '/';\n  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;\n\n  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  };\n}\n\nfunction assign(a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a;\n}\n\n/*  */\n\nfunction createMatcher(routes, router) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes(routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function match(raw, currentRoute, redirectedFrom) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        warn(record, \"Route with name '\" + name + \"' does not exist\");\n      }\n      if (!record) {\n        return _createRoute(null, location);\n      }\n      var paramNames = record.regex.keys.filter(function (key) {\n        return !key.optional;\n      }).map(function (key) {\n        return key.name;\n      });\n\n      if (_typeof(location.params) !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && _typeof(currentRoute.params) === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      if (record) {\n        location.path = fillParams(record.path, location.params, \"named route \\\"\" + name + \"\\\"\");\n        return _createRoute(record, location, redirectedFrom);\n      }\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom);\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location);\n  }\n\n  function redirect(record, location) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n      return _createRoute(null, location);\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (process.env.NODE_ENV !== 'production') {\n        assert(targetRecord, \"redirect failed: named route \\\"\" + name + \"\\\" not found.\");\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location);\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, \"redirect route with path \\\"\" + rawPath + \"\\\"\");\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location);\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n      }\n      return _createRoute(null, location);\n    }\n  }\n\n  function alias(record, location, matchAs) {\n    var aliasedPath = fillParams(matchAs, location.params, \"aliased route with path \\\"\" + matchAs + \"\\\"\");\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location);\n    }\n    return _createRoute(null, location);\n  }\n\n  function _createRoute(record, location, redirectedFrom) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location);\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs);\n    }\n    return createRoute(record, location, redirectedFrom, router);\n  }\n\n  return {\n    match: match,\n    addRoutes: addRoutes\n  };\n}\n\nfunction matchRoute(regex, path, params) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false;\n  } else if (!params) {\n    return true;\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n    if (key) {\n      params[key.name] = val;\n    }\n  }\n\n  return true;\n}\n\nfunction resolveRecordPath(path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true);\n}\n\n/*  */\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll() {\n  window.addEventListener('popstate', function (e) {\n    saveScrollPosition();\n    if (e.state && e.state.key) {\n      setStateKey(e.state.key);\n    }\n  });\n}\n\nfunction handleScroll(router, to, from, isPop) {\n  if (!router.app) {\n    return;\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior(to, from, isPop ? position : null);\n    if (!shouldScroll) {\n      return;\n    }\n    var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n      if (el) {\n        var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};\n        offset = normalizeOffset(offset);\n        position = getElementPosition(el, offset);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  });\n}\n\nfunction saveScrollPosition() {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction getScrollPosition() {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key];\n  }\n}\n\nfunction getElementPosition(el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  };\n}\n\nfunction isValidPosition(obj) {\n  return isNumber(obj.x) || isNumber(obj.y);\n}\n\nfunction normalizePosition(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  };\n}\n\nfunction normalizeOffset(obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  };\n}\n\nfunction isNumber(v) {\n  return typeof v === 'number';\n}\n\n/*  */\n\nvar supportsPushState = inBrowser && function () {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n\n  return window.history && 'pushState' in window.history;\n}();\n\n// use User Timing api (if present) for more accurate key precision\nvar Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;\n\nvar _key = genKey();\n\nfunction genKey() {\n  return Time.now().toFixed(3);\n}\n\nfunction getStateKey() {\n  return _key;\n}\n\nfunction setStateKey(key) {\n  _key = key;\n}\n\nfunction pushState(url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      history.replaceState({ key: _key }, '', url);\n    } else {\n      _key = genKey();\n      history.pushState({ key: _key }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState(url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue(queue, fn, cb) {\n  var step = function step(index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n/*  */\n\nfunction resolveAsyncComponents(matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (resolvedDef.__esModule && resolvedDef.default) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n          process.env.NODE_ENV !== 'production' && warn(false, msg);\n          if (!error) {\n            error = isError(reason) ? reason : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) {\n      next();\n    }\n  };\n}\n\nfunction flatMapComponents(matched, fn) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return fn(m.components[key], m.instances[key], m, key);\n    });\n  }));\n}\n\nfunction flatten(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once(fn) {\n  var called = false;\n  return function () {\n    var args = [],\n        len = arguments.length;\n    while (len--) {\n      args[len] = arguments[len];\n    }if (called) {\n      return;\n    }\n    called = true;\n    return fn.apply(this, args);\n  };\n}\n\n/*  */\n\nvar History = function History(router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n};\n\nHistory.prototype.listen = function listen(cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady(cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError(errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n  var this$1 = this;\n\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(route, function () {\n    this$1.updateRoute(route);\n    onComplete && onComplete(route);\n    this$1.ensureURL();\n\n    // fire ready cbs once\n    if (!this$1.ready) {\n      this$1.ready = true;\n      this$1.readyCbs.forEach(function (cb) {\n        cb(route);\n      });\n    }\n  }, function (err) {\n    if (onAbort) {\n      onAbort(err);\n    }\n    if (err && !this$1.ready) {\n      this$1.ready = true;\n      this$1.readyErrorCbs.forEach(function (cb) {\n        cb(err);\n      });\n    }\n  });\n};\n\nHistory.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {\n  var this$1 = this;\n\n  var current = this.current;\n  var abort = function abort(err) {\n    if (isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) {\n          cb(err);\n        });\n      } else {\n        warn(false, 'uncaught error during route navigation:');\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  if (isSameRoute(route, current) &&\n  // in the case the route map has been dynamically appended to\n  route.matched.length === current.matched.length) {\n    this.ensureURL();\n    return abort();\n  }\n\n  var ref = resolveQueue(this.current.matched, route.matched);\n  var updated = ref.updated;\n  var deactivated = ref.deactivated;\n  var activated = ref.activated;\n\n  var queue = [].concat(\n  // in-component leave guards\n  extractLeaveGuards(deactivated),\n  // global before hooks\n  this.router.beforeHooks,\n  // in-component update hooks\n  extractUpdateHooks(updated),\n  // in-config enter guards\n  activated.map(function (m) {\n    return m.beforeEnter;\n  }),\n  // async components\n  resolveAsyncComponents(activated));\n\n  this.pending = route;\n  var iterator = function iterator(hook, next) {\n    if (this$1.pending !== route) {\n      return abort();\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false || isError(to)) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort();\n          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    var postEnterCbs = [];\n    var isValid = function isValid() {\n      return this$1.current === route;\n    };\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort();\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          postEnterCbs.forEach(function (cb) {\n            cb();\n          });\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute(route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function (hook) {\n    hook && hook(route, prev);\n  });\n};\n\nfunction normalizeBase(base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '');\n}\n\nfunction resolveQueue(current, next) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break;\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  };\n}\n\nfunction extractGuards(records, name, bind, reverse) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard) ? guard.map(function (guard) {\n        return bind(guard, instance, match, key);\n      }) : bind(guard, instance, match, key);\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards);\n}\n\nfunction extractGuard(def, key) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key];\n}\n\nfunction extractLeaveGuards(deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);\n}\n\nfunction extractUpdateHooks(updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);\n}\n\nfunction bindGuard(guard, instance) {\n  if (instance) {\n    return function boundRouteGuard() {\n      return guard.apply(instance, arguments);\n    };\n  }\n}\n\nfunction extractEnterGuards(activated, cbs, isValid) {\n  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n    return bindEnterGuard(guard, match, key, cbs, isValid);\n  });\n}\n\nfunction bindEnterGuard(guard, match, key, cbs, isValid) {\n  return function routeEnterGuard(to, from, next) {\n    return guard(to, from, function (cb) {\n      next(cb);\n      if (typeof cb === 'function') {\n        cbs.push(function () {\n          // #750\n          // if a router-view is wrapped with an out-in transition,\n          // the instance may not have been registered at this time.\n          // we will need to poll for registration until current route\n          // is no longer valid.\n          poll(cb, match.instances, key, isValid);\n        });\n      }\n    });\n  };\n}\n\nfunction poll(cb, // somehow flow cannot infer this is a function\ninstances, key, isValid) {\n  if (instances[key]) {\n    cb(instances[key]);\n  } else if (isValid()) {\n    setTimeout(function () {\n      poll(cb, instances, key, isValid);\n    }, 16);\n  }\n}\n\n/*  */\n\nvar HTML5History = function (History$$1) {\n  function HTML5History(router, base) {\n    var this$1 = this;\n\n    History$$1.call(this, router, base);\n\n    var expectScroll = router.options.scrollBehavior;\n\n    if (expectScroll) {\n      setupScroll();\n    }\n\n    window.addEventListener('popstate', function (e) {\n      var current = this$1.current;\n      this$1.transitionTo(getLocation(this$1.base), function (route) {\n        if (expectScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    });\n  }\n\n  if (History$$1) HTML5History.__proto__ = History$$1;\n  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL(push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getLocation(this.base);\n  };\n\n  return HTML5History;\n}(History);\n\nfunction getLocation(base) {\n  var path = window.location.pathname;\n  if (base && path.indexOf(base) === 0) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash;\n}\n\n/*  */\n\nvar HashHistory = function (History$$1) {\n  function HashHistory(router, base, fallback) {\n    History$$1.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return;\n    }\n    ensureSlash();\n  }\n\n  if (History$$1) HashHistory.__proto__ = History$$1;\n  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners() {\n    var this$1 = this;\n\n    window.addEventListener('hashchange', function () {\n      if (!ensureSlash()) {\n        return;\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        replaceHash(route.fullPath);\n      });\n    });\n  };\n\n  HashHistory.prototype.push = function push(location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      pushHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    this.transitionTo(location, function (route) {\n      replaceHash(route.fullPath);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HashHistory.prototype.go = function go(n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL(push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    return getHash();\n  };\n\n  return HashHistory;\n}(History);\n\nfunction checkFallback(base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location));\n    return true;\n  }\n}\n\nfunction ensureSlash() {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true;\n  }\n  replaceHash('/' + path);\n  return false;\n}\n\nfunction getHash() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  return index === -1 ? '' : href.slice(index + 1);\n}\n\nfunction pushHash(path) {\n  window.location.hash = path;\n}\n\nfunction replaceHash(path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  window.location.replace(base + \"#\" + path);\n}\n\n/*  */\n\nvar AbstractHistory = function (History$$1) {\n  function AbstractHistory(router, base) {\n    History$$1.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if (History$$1) AbstractHistory.__proto__ = History$$1;\n  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n      this$1.index++;\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(location, function (route) {\n      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  AbstractHistory.prototype.go = function go(n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return;\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(route, function () {\n      this$1.index = targetIndex;\n      this$1.updateRoute(route);\n    });\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/';\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL() {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History);\n\n/*  */\n\nvar VueRouter = function VueRouter(options) {\n  if (options === void 0) options = {};\n\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break;\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break;\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break;\n    default:\n      if (process.env.NODE_ENV !== 'production') {\n        assert(false, \"invalid mode: \" + mode);\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: {} };\n\nVueRouter.prototype.match = function match(raw, current, redirectedFrom) {\n  return this.matcher.match(raw, current, redirectedFrom);\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current;\n};\n\nVueRouter.prototype.init = function init(app /* Vue component instance */) {\n  var this$1 = this;\n\n  process.env.NODE_ENV !== 'production' && assert(install.installed, \"not installed. Make sure to call `Vue.use(VueRouter)` \" + \"before creating root instance.\");\n\n  this.apps.push(app);\n\n  // main app already initialized.\n  if (this.app) {\n    return;\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History) {\n    history.transitionTo(history.getCurrentLocation());\n  } else if (history instanceof HashHistory) {\n    var setupHashListener = function setupHashListener() {\n      history.setupListeners();\n    };\n    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach(fn) {\n  return registerHook(this.beforeHooks, fn);\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve(fn) {\n  return registerHook(this.resolveHooks, fn);\n};\n\nVueRouter.prototype.afterEach = function afterEach(fn) {\n  return registerHook(this.afterHooks, fn);\n};\n\nVueRouter.prototype.onReady = function onReady(cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError(errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push(location, onComplete, onAbort) {\n  this.history.push(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.replace = function replace(location, onComplete, onAbort) {\n  this.history.replace(location, onComplete, onAbort);\n};\n\nVueRouter.prototype.go = function go(n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back() {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward() {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {\n  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;\n  if (!route) {\n    return [];\n  }\n  return [].concat.apply([], route.matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) {\n      return m.components[key];\n    });\n  }));\n};\n\nVueRouter.prototype.resolve = function resolve(to, current, append) {\n  var location = normalizeLocation(to, current || this.history.current, append, this);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  };\n};\n\nVueRouter.prototype.addRoutes = function addRoutes(routes) {\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties(VueRouter.prototype, prototypeAccessors);\n\nfunction registerHook(list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) {\n      list.splice(i, 1);\n    }\n  };\n}\n\nfunction createHref(base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path;\n}\n\nVueRouter.install = install;\nVueRouter.version = '2.7.0';\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VueRouter);\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(3)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLjIuNy4wQHZ1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcz85ZDg5Il0sIm5hbWVzIjpbImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsIndhcm4iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJjb25zb2xlIiwiaXNFcnJvciIsImVyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImluZGV4T2YiLCJWaWV3IiwibmFtZSIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwicmVuZGVyIiwiXyIsInJlZiIsImNoaWxkcmVuIiwicGFyZW50IiwiZGF0YSIsInJvdXRlclZpZXciLCJoIiwiJGNyZWF0ZUVsZW1lbnQiLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCJfcm91dGVyUm9vdCIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwidmFsIiwiY3VycmVudCIsImluc3RhbmNlcyIsImhvb2siLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJyZXNvbHZlUHJvcHMiLCJjb25maWciLCJwYXJhbXMiLCJ1bmRlZmluZWQiLCJwYXRoIiwiZW5jb2RlUmVzZXJ2ZVJFIiwiZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyIiwiYyIsImNoYXJDb2RlQXQiLCJjb21tYVJFIiwiZW5jb2RlIiwic3RyIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlc29sdmVRdWVyeSIsInF1ZXJ5IiwiZXh0cmFRdWVyeSIsIl9wYXJzZVF1ZXJ5IiwicGFyc2UiLCJwYXJzZVF1ZXJ5IiwicGFyc2VkUXVlcnkiLCJlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJyZXMiLCJ0cmltIiwic3BsaXQiLCJmb3JFYWNoIiwicGFyYW0iLCJwYXJ0cyIsInNoaWZ0IiwibGVuZ3RoIiwiam9pbiIsInB1c2giLCJzdHJpbmdpZnlRdWVyeSIsIm9iaiIsImtleXMiLCJtYXAiLCJyZXN1bHQiLCJ2YWwyIiwiZmlsdGVyIiwieCIsInRyYWlsaW5nU2xhc2hSRSIsImNyZWF0ZVJvdXRlIiwicmVjb3JkIiwibG9jYXRpb24iLCJyZWRpcmVjdGVkRnJvbSIsInJvdXRlciIsInN0cmluZ2lmeVF1ZXJ5JCQxIiwib3B0aW9ucyIsIm1ldGEiLCJoYXNoIiwiZnVsbFBhdGgiLCJnZXRGdWxsUGF0aCIsImZvcm1hdE1hdGNoIiwiZnJlZXplIiwiU1RBUlQiLCJ1bnNoaWZ0IiwiX3N0cmluZ2lmeVF1ZXJ5Iiwic3RyaW5naWZ5IiwiaXNTYW1lUm91dGUiLCJhIiwiYiIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJhVmFsIiwiYlZhbCIsImlzSW5jbHVkZWRSb3V0ZSIsInRhcmdldCIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJ0byIsInJlcXVpcmVkIiwidGFnIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwiYWN0aXZlQ2xhc3MiLCJleGFjdEFjdGl2ZUNsYXNzIiwiZXZlbnQiLCJ0aGlzJDEiLCIkcm91dGVyIiwicmVzb2x2ZSIsImhyZWYiLCJjbGFzc2VzIiwiZ2xvYmFsQWN0aXZlQ2xhc3MiLCJsaW5rQWN0aXZlQ2xhc3MiLCJnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzIiwibGlua0V4YWN0QWN0aXZlQ2xhc3MiLCJhY3RpdmVDbGFzc0ZhbGxiYWNrIiwiZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrIiwiY29tcGFyZVRhcmdldCIsImhhbmRsZXIiLCJndWFyZEV2ZW50Iiwib24iLCJjbGljayIsImNsYXNzIiwiYXR0cnMiLCJmaW5kQW5jaG9yIiwiJHNsb3RzIiwiaXNTdGF0aWMiLCJleHRlbmQiLCJfVnVlIiwidXRpbCIsImFEYXRhIiwiYUF0dHJzIiwibWV0YUtleSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidXR0b24iLCJjdXJyZW50VGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwidGVzdCIsInByZXZlbnREZWZhdWx0IiwiY2hpbGQiLCJpIiwiaW5zdGFsbCIsIlZ1ZSIsImluc3RhbGxlZCIsImlzRGVmIiwidiIsInJlZ2lzdGVySW5zdGFuY2UiLCJjYWxsVmFsIiwiJG9wdGlvbnMiLCJfcGFyZW50Vm5vZGUiLCJtaXhpbiIsImJlZm9yZUNyZWF0ZSIsIl9yb3V0ZXIiLCJpbml0IiwiZGVmaW5lUmVhY3RpdmUiLCJoaXN0b3J5IiwiZGVzdHJveWVkIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJfcm91dGUiLCJzdHJhdHMiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJiZWZvcmVSb3V0ZUVudGVyIiwiYmVmb3JlUm91dGVMZWF2ZSIsImJlZm9yZVJvdXRlVXBkYXRlIiwiY3JlYXRlZCIsImluQnJvd3NlciIsIndpbmRvdyIsInJlc29sdmVQYXRoIiwicmVsYXRpdmUiLCJiYXNlIiwiZmlyc3RDaGFyIiwiY2hhckF0Iiwic3RhY2siLCJwb3AiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJwYXJzZVBhdGgiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwiaW5kZXgkMSIsImFyciIsImluZGV4IiwicGF0aFRvUmVnZXhwIiwicGFyc2VfMSIsImNvbXBpbGVfMSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uXzEiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHBfMSIsInRva2Vuc1RvUmVnRXhwIiwiUEFUSF9SRUdFWFAiLCJSZWdFeHAiLCJ0b2tlbnMiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsInZhbHVlIiwiVHlwZUVycm9yIiwiSlNPTiIsImoiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwic291cmNlIiwibWF0Y2giLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJzdHJpY3QiLCJlbmQiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImNyZWF0ZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsImNyZWF0ZVJvdXRlTWFwIiwicm91dGVzIiwib2xkUGF0aExpc3QiLCJvbGRQYXRoTWFwIiwib2xkTmFtZU1hcCIsInBhdGhMaXN0IiwicGF0aE1hcCIsIm5hbWVNYXAiLCJhZGRSb3V0ZVJlY29yZCIsImwiLCJzcGxpY2UiLCJtYXRjaEFzIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVQYXRoIiwicGF0aFRvUmVnZXhwT3B0aW9ucyIsImNhc2VTZW5zaXRpdmUiLCJyZWdleCIsImNvbXBpbGVSb3V0ZVJlZ2V4IiwicmVkaXJlY3QiLCJiZWZvcmVFbnRlciIsInNvbWUiLCJjaGlsZE1hdGNoQXMiLCJhbGlhcyIsImFsaWFzZXMiLCJhbGlhc1JvdXRlIiwibm9ybWFsaXplTG9jYXRpb24iLCJyYXciLCJfbm9ybWFsaXplZCIsImFzc2lnbiIsInJhd1BhdGgiLCJwYXJzZWRQYXRoIiwiYmFzZVBhdGgiLCJjcmVhdGVNYXRjaGVyIiwiYWRkUm91dGVzIiwiY3VycmVudFJvdXRlIiwiX2NyZWF0ZVJvdXRlIiwicGFyYW1OYW1lcyIsInJlY29yZCQxIiwibWF0Y2hSb3V0ZSIsIm9yaWdpbmFsUmVkaXJlY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInRhcmdldFJlY29yZCIsInJlc29sdmVSZWNvcmRQYXRoIiwicmVzb2x2ZWRQYXRoIiwiYWxpYXNlZFBhdGgiLCJhbGlhc2VkTWF0Y2giLCJhbGlhc2VkUmVjb3JkIiwibGVuIiwicG9zaXRpb25TdG9yZSIsInNldHVwU2Nyb2xsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInN0YXRlIiwic2V0U3RhdGVLZXkiLCJoYW5kbGVTY3JvbGwiLCJmcm9tIiwiaXNQb3AiLCJhcHAiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwiJG5leHRUaWNrIiwicG9zaXRpb24iLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNob3VsZFNjcm9sbCIsImlzT2JqZWN0Iiwic2VsZWN0b3IiLCJlbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIm5vcm1hbGl6ZU9mZnNldCIsImdldEVsZW1lbnRQb3NpdGlvbiIsImlzVmFsaWRQb3NpdGlvbiIsIm5vcm1hbGl6ZVBvc2l0aW9uIiwic2Nyb2xsVG8iLCJ5IiwiZ2V0U3RhdGVLZXkiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiZG9jRWwiLCJkb2N1bWVudEVsZW1lbnQiLCJkb2NSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZWxSZWN0IiwibGVmdCIsInRvcCIsImlzTnVtYmVyIiwic3VwcG9ydHNQdXNoU3RhdGUiLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIlRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJfa2V5IiwiZ2VuS2V5IiwidG9GaXhlZCIsInB1c2hTdGF0ZSIsInVybCIsInJlcGxhY2VTdGF0ZSIsInJ1blF1ZXVlIiwicXVldWUiLCJmbiIsImNiIiwic3RlcCIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJoYXNBc3luYyIsInBlbmRpbmciLCJlcnJvciIsImZsYXRNYXBDb21wb25lbnRzIiwiZGVmIiwiY2lkIiwib25jZSIsInJlc29sdmVkRGVmIiwiX19lc01vZHVsZSIsInJlc29sdmVkIiwicmVqZWN0IiwicmVhc29uIiwibXNnIiwidGhlbiIsImNvbXAiLCJmbGF0dGVuIiwiY29uY2F0IiwiYXBwbHkiLCJjYWxsZWQiLCJhcmdzIiwiYXJndW1lbnRzIiwiSGlzdG9yeSIsIm5vcm1hbGl6ZUJhc2UiLCJyZWFkeSIsInJlYWR5Q2JzIiwicmVhZHlFcnJvckNicyIsImVycm9yQ2JzIiwibGlzdGVuIiwib25SZWFkeSIsImVycm9yQ2IiLCJvbkVycm9yIiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsIml0ZXJhdG9yIiwicG9zdEVudGVyQ2JzIiwiaXNWYWxpZCIsImVudGVyR3VhcmRzIiwiZXh0cmFjdEVudGVyR3VhcmRzIiwicmVzb2x2ZUhvb2tzIiwicHJldiIsImFmdGVySG9va3MiLCJiYXNlRWwiLCJtYXgiLCJNYXRoIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJiaW5kIiwicmV2ZXJzZSIsImd1YXJkcyIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJjYnMiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJzZXRUaW1lb3V0IiwiSFRNTDVIaXN0b3J5IiwiSGlzdG9yeSQkMSIsImV4cGVjdFNjcm9sbCIsImdldExvY2F0aW9uIiwiX19wcm90b19fIiwiY29uc3RydWN0b3IiLCJnbyIsIm4iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsIkhhc2hIaXN0b3J5IiwiZmFsbGJhY2siLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsImdldEhhc2giLCJyZXBsYWNlSGFzaCIsInB1c2hIYXNoIiwiQWJzdHJhY3RIaXN0b3J5IiwidGFyZ2V0SW5kZXgiLCJWdWVSb3V0ZXIiLCJhcHBzIiwibWF0Y2hlciIsIm1vZGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJzZXR1cEhhc2hMaXN0ZW5lciIsImJlZm9yZUVhY2giLCJyZWdpc3Rlckhvb2siLCJiZWZvcmVSZXNvbHZlIiwiYWZ0ZXJFYWNoIiwiYmFjayIsImZvcndhcmQiLCJnZXRNYXRjaGVkQ29tcG9uZW50cyIsImNyZWF0ZUhyZWYiLCJub3JtYWxpemVkVG8iLCJkZWZpbmVQcm9wZXJ0aWVzIiwibGlzdCIsInZlcnNpb24iLCJ1c2UiXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7OztBQUtBOztBQUVBLFNBQVNBLE1BQVQsQ0FBaUJDLFNBQWpCLEVBQTRCQyxPQUE1QixFQUFxQztBQUNuQyxNQUFJLENBQUNELFNBQUwsRUFBZ0I7QUFDZCxVQUFNLElBQUlFLEtBQUosQ0FBVyxrQkFBa0JELE9BQTdCLENBQU47QUFDRDtBQUNGOztBQUVELFNBQVNFLElBQVQsQ0FBZUgsU0FBZixFQUEwQkMsT0FBMUIsRUFBbUM7QUFDakMsTUFBSUcsUUFBUUMsR0FBUixDQUFZQyxRQUFaLEtBQXlCLFlBQXpCLElBQXlDLENBQUNOLFNBQTlDLEVBQXlEO0FBQ3ZELFdBQU9PLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0NBLFFBQVFKLElBQVIsQ0FBYyxrQkFBa0JGLE9BQWhDLENBQWxDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTTyxPQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNy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LEdBQXhCLEVBQTZCO0FBQzNCeUIsU0FBT3pCLEdBQVAsQ0FBV2dVLEdBQVgsQ0FBZWxCLFNBQWY7QUFDRDs7QUFFRCwrREFBZUEsU0FBZixFIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICogdnVlLXJvdXRlciB2Mi43LjBcbiAgKiAoYykgMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuLyogICovXG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm4gKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvciAoZXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKS5pbmRleE9mKCdFcnJvcicpID4gLTFcbn1cblxudmFyIFZpZXcgPSB7XG4gIG5hbWU6ICdyb3V0ZXItdmlldycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoXywgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIC8vIGRpcmVjdGx5IHVzZSBwYXJlbnQgY29udGV4dCdzIGNyZWF0ZUVsZW1lbnQoKSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcG9uZW50cyByZW5kZXJlZCBieSByb3V0ZXItdmlldyBjYW4gcmVzb2x2ZSBuYW1lZCBzbG90c1xuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gYXR0YWNoIGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBpbmplY3RlZCBsaWZlY3ljbGUgaG9va3NcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XG4gICAgICAvLyB2YWwgY291bGQgYmUgdW5kZWZpbmVkIGZvciB1bnJlZ2lzdHJhdGlvblxuICAgICAgdmFyIGN1cnJlbnQgPSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbCAmJiBjdXJyZW50ICE9PSB2bSkgfHxcbiAgICAgICAgKCF2YWwgJiYgY3VycmVudCA9PT0gdm0pXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxzbyByZWdpc2V0ZXIgaW5zdGFuY2UgaW4gcHJlcGF0Y2ggaG9va1xuICAgIC8vIGluIGNhc2UgdGhlIHNhbWUgY29tcG9uZW50IGluc3RhbmNlIGlzIHJldXNlZCBhY3Jvc3MgZGlmZmVyZW50IHJvdXRlc1xuICAgIDsoZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSkpLnByZXBhdGNoID0gZnVuY3Rpb24gKF8sIHZub2RlKSB7XG4gICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyByZXNvbHZlIHByb3BzXG4gICAgZGF0YS5wcm9wcyA9IHJlc29sdmVQcm9wcyhyb3V0ZSwgbWF0Y2hlZC5wcm9wcyAmJiBtYXRjaGVkLnByb3BzW25hbWVdKTtcblxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgXCIgK1xuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcbiAgLnJlcGxhY2UoY29tbWFSRSwgJywnKTsgfTtcblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnksXG4gIF9wYXJzZVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcbiAgdmFyIHBhcnNlZFF1ZXJ5O1xuICB0cnkge1xuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICB2YXIgdmFsID0gZXh0cmFRdWVyeVtrZXldO1xuICAgIHBhcnNlZFF1ZXJ5W2tleV0gPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwuc2xpY2UoKSA6IHZhbDtcbiAgfVxuICByZXR1cm4gcGFyc2VkUXVlcnlcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkpIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcbiAgICAgID8gZGVjb2RlKHBhcnRzLmpvaW4oJz0nKSlcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChyZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XG4gICAgICByZXNba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqKSB7XG4gIHZhciByZXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGtleSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiAodmFsMikge1xuICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbClcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lmxlbmd0aCA+IDA7IH0pLmpvaW4oJyYnKSA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cblxudmFyIHRyYWlsaW5nU2xhc2hSRSA9IC9cXC8/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlIChcbiAgcmVjb3JkLFxuICBsb2NhdGlvbixcbiAgcmVkaXJlY3RlZEZyb20sXG4gIHJvdXRlclxuKSB7XG4gIHZhciBzdHJpbmdpZnlRdWVyeSQkMSA9IHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogbG9jYXRpb24ucXVlcnkgfHwge30sXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uLCBzdHJpbmdpZnlRdWVyeSQkMSksXG4gICAgbWF0Y2hlZDogcmVjb3JkID8gZm9ybWF0TWF0Y2gocmVjb3JkKSA6IFtdXG4gIH07XG4gIGlmIChyZWRpcmVjdGVkRnJvbSkge1xuICAgIHJvdXRlLnJlZGlyZWN0ZWRGcm9tID0gZ2V0RnVsbFBhdGgocmVkaXJlY3RlZEZyb20sIHN0cmluZ2lmeVF1ZXJ5JCQxKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcbn1cblxuLy8gdGhlIHN0YXJ0aW5nIHJvdXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5pdGlhbCBzdGF0ZVxudmFyIFNUQVJUID0gY3JlYXRlUm91dGUobnVsbCwge1xuICBwYXRoOiAnLydcbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXRNYXRjaCAocmVjb3JkKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgd2hpbGUgKHJlY29yZCkge1xuICAgIHJlcy51bnNoaWZ0KHJlY29yZCk7XG4gICAgcmVjb3JkID0gcmVjb3JkLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoIChcbiAgcmVmLFxuICBfc3RyaW5naWZ5UXVlcnlcbikge1xuICB2YXIgcGF0aCA9IHJlZi5wYXRoO1xuICB2YXIgcXVlcnkgPSByZWYucXVlcnk7IGlmICggcXVlcnkgPT09IHZvaWQgMCApIHF1ZXJ5ID0ge307XG4gIHZhciBoYXNoID0gcmVmLmhhc2g7IGlmICggaGFzaCA9PT0gdm9pZCAwICkgaGFzaCA9ICcnO1xuXG4gIHZhciBzdHJpbmdpZnkgPSBfc3RyaW5naWZ5UXVlcnkgfHwgc3RyaW5naWZ5UXVlcnk7XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgc3RyaW5naWZ5KHF1ZXJ5KSArIGhhc2hcbn1cblxuZnVuY3Rpb24gaXNTYW1lUm91dGUgKGEsIGIpIHtcbiAgaWYgKGIgPT09IFNUQVJUKSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfSBlbHNlIGlmICghYikge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGEucGF0aCAmJiBiLnBhdGgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgPT09IGIucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KVxuICAgIClcbiAgfSBlbHNlIGlmIChhLm5hbWUgJiYgYi5uYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEubmFtZSA9PT0gYi5uYW1lICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KSAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnBhcmFtcywgYi5wYXJhbXMpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RXF1YWwgKGEsIGIpIHtcbiAgaWYgKCBhID09PSB2b2lkIDAgKSBhID0ge307XG4gIGlmICggYiA9PT0gdm9pZCAwICkgYiA9IHt9O1xuXG4gIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgYVZhbCA9IGFba2V5XTtcbiAgICB2YXIgYlZhbCA9IGJba2V5XTtcbiAgICAvLyBjaGVjayBuZXN0ZWQgZXF1YWxpdHlcbiAgICBpZiAodHlwZW9mIGFWYWwgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiVmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0RXF1YWwoYVZhbCwgYlZhbClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhVmFsKSA9PT0gU3RyaW5nKGJWYWwpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgY3VycmVudC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpLmluZGV4T2YoXG4gICAgICB0YXJnZXQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKVxuICAgICkgPT09IDAgJiZcbiAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG4gICAgcXVlcnlJbmNsdWRlcyhjdXJyZW50LnF1ZXJ5LCB0YXJnZXQucXVlcnkpXG4gIClcbn1cblxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKiAgKi9cblxuLy8gd29yayBhcm91bmQgd2VpcmQgZmxvdyBidWdcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcbnZhciBldmVudFR5cGVzID0gW1N0cmluZywgQXJyYXldO1xuXG52YXIgTGluayA9IHtcbiAgbmFtZTogJ3JvdXRlci1saW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuJHJvdXRlO1xuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZSh0aGlzLnRvLCBjdXJyZW50LCB0aGlzLmFwcGVuZCk7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZSA9IHJlZi5yb3V0ZTtcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsQWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcztcbiAgICAvLyBTdXBwb3J0IGdsb2JhbCBlbXB0eSBhY3RpdmUgY2xhc3NcbiAgICB2YXIgYWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstZXhhY3QtYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBhY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPSB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5leGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBjb21wYXJlVGFyZ2V0ID0gbG9jYXRpb24ucGF0aFxuICAgICAgPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKVxuICAgICAgOiByb3V0ZTtcblxuICAgIGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc10gPSBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXVxuICAgICAgOiBpc0luY2x1ZGVkUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xuICAgICAgICBpZiAodGhpcyQxLnJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXIucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyLnB1c2gobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IHsgY2xpY2s6IGd1YXJkRXZlbnQgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IG9uW2VdID0gaGFuZGxlcjsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW3RoaXMuZXZlbnRdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XG4gICAgICBkYXRhLm9uID0gb247XG4gICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcbiAgICAgIHZhciBhID0gZmluZEFuY2hvcih0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXG4gICAgICAgIGEuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dGVuZCA9IF9WdWUudXRpbC5leHRlbmQ7XG4gICAgICAgIHZhciBhRGF0YSA9IGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKTtcbiAgICAgICAgYURhdGEub24gPSBvbjtcbiAgICAgICAgdmFyIGFBdHRycyA9IGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKTtcbiAgICAgICAgYUF0dHJzLmhyZWYgPSBocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIDxhPiBjaGlsZCwgYXBwbHkgbGlzdGVuZXIgdG8gc2VsZlxuICAgICAgICBkYXRhLm9uID0gb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGhpcy50YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGd1YXJkRXZlbnQgKGUpIHtcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcbiAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCB3aGVuIHByZXZlbnREZWZhdWx0IGNhbGxlZFxuICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gIGlmIChlLmJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9uICE9PSAwKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IGlmIGB0YXJnZXQ9XCJfYmxhbmtcImBcbiAgaWYgKGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKSB7IHJldHVybiB9XG4gIH1cbiAgLy8gdGhpcyBtYXkgYmUgYSBXZWV4IGV2ZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZFxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaW5kQW5jaG9yIChjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICdhJykge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiAoY2hpbGQgPSBmaW5kQW5jaG9yKGNoaWxkLmNoaWxkcmVuKSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBfVnVlO1xuXG5mdW5jdGlvbiBpbnN0YWxsIChWdWUpIHtcbiAgaWYgKGluc3RhbGwuaW5zdGFsbGVkKSB7IHJldHVybiB9XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcblxuICBfVnVlID0gVnVlO1xuXG4gIHZhciBpc0RlZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH07XG5cbiAgdmFyIHJlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIGNhbGxWYWwpIHtcbiAgICB2YXIgaSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkuZGF0YSkgJiYgaXNEZWYoaSA9IGkucmVnaXN0ZXJSb3V0ZUluc3RhbmNlKSkge1xuICAgICAgaSh2bSwgY2FsbFZhbCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5taXhpbih7XG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuICAgICAgaWYgKGlzRGVmKHRoaXMuJG9wdGlvbnMucm91dGVyKSkge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gKHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuX3JvdXRlclJvb3QpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZXIgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZSB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci1saW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmJlZm9yZVJvdXRlVXBkYXRlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICB2YXIgZmlyc3RDaGFyID0gcmVsYXRpdmUuY2hhckF0KDApO1xuICBpZiAoZmlyc3RDaGFyID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxudmFyIGluZGV4JDEgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIGluZGV4ID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCQxKHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWluZGV4JDEoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpbmRleCQxKGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpbmRleCQxKHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5pbmRleC5wYXJzZSA9IHBhcnNlXzE7XG5pbmRleC5jb21waWxlID0gY29tcGlsZV8xO1xuaW5kZXgudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbmluZGV4LnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBpbmRleC5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTGlzdCxcbiAgb2xkUGF0aE1hcCxcbiAgb2xkTmFtZU1hcFxuKSB7XG4gIC8vIHRoZSBwYXRoIGxpc3QgaXMgdXNlZCB0byBjb250cm9sIHBhdGggbWF0Y2hpbmcgcHJpb3JpdHlcbiAgdmFyIHBhdGhMaXN0ID0gb2xkUGF0aExpc3QgfHwgW107XG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbmFtZU1hcCA9IG9sZE5hbWVNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgcm91dGUpO1xuICB9KTtcblxuICAvLyBlbnN1cmUgd2lsZGNhcmQgcm91dGVzIGFyZSBhbHdheXMgYXQgdGhlIGVuZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XG4gICAgICBwYXRoTGlzdC5wdXNoKHBhdGhMaXN0LnNwbGljZShpLCAxKVswXSk7XG4gICAgICBsLS07XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTGlzdDogcGF0aExpc3QsXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcbiAgICBuYW1lTWFwOiBuYW1lTWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuICBwYXRoTGlzdCxcbiAgcGF0aE1hcCxcbiAgbmFtZU1hcCxcbiAgcm91dGUsXG4gIHBhcmVudCxcbiAgbWF0Y2hBc1xuKSB7XG4gIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgdmFyIG5hbWUgPSByb3V0ZS5uYW1lO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKHBhdGggfHwgbmFtZSkpICsgXCIgY2Fubm90IGJlIGEgXCIgK1xuICAgICAgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoLCBwYXJlbnQpO1xuICB2YXIgcGF0aFRvUmVnZXhwT3B0aW9ucyA9IHJvdXRlLnBhdGhUb1JlZ2V4cE9wdGlvbnMgfHwge307XG5cbiAgaWYgKHR5cGVvZiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSAnYm9vbGVhbicpIHtcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnNlbnNpdGl2ZSA9IHJvdXRlLmNhc2VTZW5zaXRpdmU7XG4gIH1cblxuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucyksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxuICAgICAgPyB7fVxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgID8gcm91dGUucHJvcHNcbiAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkLCBkb2VzIG5vdCByZWRpcmVjdCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChyb3V0ZS5uYW1lICYmICFyb3V0ZS5yZWRpcmVjdCAmJiByb3V0ZS5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gL15cXC8/JC8udGVzdChjaGlsZC5wYXRoKTsgfSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIk5hbWVkIFJvdXRlICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJyBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLiBcIiArXG4gICAgICAgICAgXCJXaGVuIG5hdmlnYXRpbmcgdG8gdGhpcyBuYW1lZCByb3V0ZSAoOnRvPVxcXCJ7bmFtZTogJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInXFxcIiksIFwiICtcbiAgICAgICAgICBcInRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBSZW1vdmUgdGhlIG5hbWUgZnJvbSBcIiArXG4gICAgICAgICAgXCJ0aGlzIHJvdXRlIGFuZCB1c2UgdGhlIG5hbWUgb2YgdGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgZm9yIG5hbWVkIFwiICtcbiAgICAgICAgICBcImxpbmtzIGluc3RlYWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcm91dGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE1hdGNoQXMgPSBtYXRjaEFzXG4gICAgICAgID8gY2xlYW5QYXRoKChtYXRjaEFzICsgXCIvXCIgKyAoY2hpbGQucGF0aCkpKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCBjaGlsZCwgcmVjb3JkLCBjaGlsZE1hdGNoQXMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJvdXRlLmFsaWFzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgYWxpYXNlcyA9IEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpXG4gICAgICA/IHJvdXRlLmFsaWFzXG4gICAgICA6IFtyb3V0ZS5hbGlhc107XG5cbiAgICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgcGF0aDogYWxpYXMsXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxuICAgICAgfTtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKFxuICAgICAgICBwYXRoTGlzdCxcbiAgICAgICAgcGF0aE1hcCxcbiAgICAgICAgbmFtZU1hcCxcbiAgICAgICAgYWxpYXNSb3V0ZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICByZWNvcmQucGF0aCB8fCAnLycgLy8gbWF0Y2hBc1xuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghcGF0aE1hcFtyZWNvcmQucGF0aF0pIHtcbiAgICBwYXRoTGlzdC5wdXNoKHJlY29yZC5wYXRoKTtcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lTWFwW25hbWVdKSB7XG4gICAgICBuYW1lTWFwW25hbWVdID0gcmVjb3JkO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xuICAgICAgd2FybihcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXG4gICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVJvdXRlUmVnZXggKHBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpIHtcbiAgdmFyIHJlZ2V4ID0gaW5kZXgocGF0aCwgW10sIHBhdGhUb1JlZ2V4cE9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBrZXlzID0ge307XG4gICAgcmVnZXgua2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHdhcm4oIWtleXNba2V5Lm5hbWVdLCAoXCJEdXBsaWNhdGUgcGFyYW0ga2V5cyBpbiByb3V0ZSB3aXRoIHBhdGg6IFxcXCJcIiArIHBhdGggKyBcIlxcXCJcIikpO1xuICAgICAga2V5c1trZXkubmFtZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWdleFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoIChwYXRoLCBwYXJlbnQpIHtcbiAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgaWYgKHBhdGhbMF0gPT09ICcvJykgeyByZXR1cm4gcGF0aCB9XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gcGF0aCB9XG4gIHJldHVybiBjbGVhblBhdGgoKChwYXJlbnQucGF0aCkgKyBcIi9cIiArIHBhdGgpKVxufVxuXG4vKiAgKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbiAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgYXBwZW5kLFxuICByb3V0ZXJcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Lm5hbWUgfHwgbmV4dC5fbm9ybWFsaXplZCkge1xuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICAvLyByZWxhdGl2ZSBwYXJhbXNcbiAgaWYgKCFuZXh0LnBhdGggJiYgbmV4dC5wYXJhbXMgJiYgY3VycmVudCkge1xuICAgIG5leHQgPSBhc3NpZ24oe30sIG5leHQpO1xuICAgIG5leHQuX25vcm1hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBwYXJhbXMgPSBhc3NpZ24oYXNzaWduKHt9LCBjdXJyZW50LnBhcmFtcyksIG5leHQucGFyYW1zKTtcbiAgICBpZiAoY3VycmVudC5uYW1lKSB7XG4gICAgICBuZXh0Lm5hbWUgPSBjdXJyZW50Lm5hbWU7XG4gICAgICBuZXh0LnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZC5sZW5ndGgpIHtcbiAgICAgIHZhciByYXdQYXRoID0gY3VycmVudC5tYXRjaGVkW2N1cnJlbnQubWF0Y2hlZC5sZW5ndGggLSAxXS5wYXRoO1xuICAgICAgbmV4dC5wYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInBhdGggXCIgKyAoY3VycmVudC5wYXRoKSkpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybihmYWxzZSwgXCJyZWxhdGl2ZSBwYXJhbXMgbmF2aWdhdGlvbiByZXF1aXJlcyBhIGN1cnJlbnQgcm91dGUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgdmFyIHBhcnNlZFBhdGggPSBwYXJzZVBhdGgobmV4dC5wYXRoIHx8ICcnKTtcbiAgdmFyIGJhc2VQYXRoID0gKGN1cnJlbnQgJiYgY3VycmVudC5wYXRoKSB8fCAnLyc7XG4gIHZhciBwYXRoID0gcGFyc2VkUGF0aC5wYXRoXG4gICAgPyByZXNvbHZlUGF0aChwYXJzZWRQYXRoLnBhdGgsIGJhc2VQYXRoLCBhcHBlbmQgfHwgbmV4dC5hcHBlbmQpXG4gICAgOiBiYXNlUGF0aDtcblxuICB2YXIgcXVlcnkgPSByZXNvbHZlUXVlcnkoXG4gICAgcGFyc2VkUGF0aC5xdWVyeSxcbiAgICBuZXh0LnF1ZXJ5LFxuICAgIHJvdXRlciAmJiByb3V0ZXIub3B0aW9ucy5wYXJzZVF1ZXJ5XG4gICk7XG5cbiAgdmFyIGhhc2ggPSBuZXh0Lmhhc2ggfHwgcGFyc2VkUGF0aC5oYXNoO1xuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgaGFzaCA9IFwiI1wiICsgaGFzaDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiAoYSwgYikge1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGFba2V5XSA9IGJba2V5XTtcbiAgfVxuICByZXR1cm4gYVxufVxuXG4vKiAgKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaGVyIChcbiAgcm91dGVzLFxuICByb3V0ZXJcbikge1xuICB2YXIgcmVmID0gY3JlYXRlUm91dGVNYXAocm91dGVzKTtcbiAgdmFyIHBhdGhMaXN0ID0gcmVmLnBhdGhMaXN0O1xuICB2YXIgcGF0aE1hcCA9IHJlZi5wYXRoTWFwO1xuICB2YXIgbmFtZU1hcCA9IHJlZi5uYW1lTWFwO1xuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gICAgY3JlYXRlUm91dGVNYXAocm91dGVzLCBwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSwgZmFsc2UsIHJvdXRlcik7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjb3JkKSB7IHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVjb3JkLnJlZ2V4LmtleXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5Lm9wdGlvbmFsOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xuICAgICAgICAgIGlmICghKGtleSBpbiBsb2NhdGlvbi5wYXJhbXMpICYmIHBhcmFtTmFtZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhdGggPSBmaWxsUGFyYW1zKHJlY29yZC5wYXRoLCBsb2NhdGlvbi5wYXJhbXMsIChcIm5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aCkge1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aExpc3RbaV07XG4gICAgICAgIHZhciByZWNvcmQkMSA9IHBhdGhNYXBbcGF0aF07XG4gICAgICAgIGlmIChtYXRjaFJvdXRlKHJlY29yZCQxLnJlZ2V4LCBsb2NhdGlvbi5wYXRoLCBsb2NhdGlvbi5wYXJhbXMpKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQkMSwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vIG1hdGNoXG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0IChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb25cbiAgKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVkaXJlY3QgPSByZWNvcmQucmVkaXJlY3Q7XG4gICAgdmFyIHJlZGlyZWN0ID0gdHlwZW9mIG9yaWdpbmFsUmVkaXJlY3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcikpXG4gICAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG5cbiAgICB2YXIgcmUgPSByZWRpcmVjdDtcbiAgICB2YXIgbmFtZSA9IHJlLm5hbWU7XG4gICAgdmFyIHBhdGggPSByZS5wYXRoO1xuICAgIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgcGFyYW1zID0gbG9jYXRpb24ucGFyYW1zO1xuICAgIHF1ZXJ5ID0gcmUuaGFzT3duUHJvcGVydHkoJ3F1ZXJ5JykgPyByZS5xdWVyeSA6IHF1ZXJ5O1xuICAgIGhhc2ggPSByZS5oYXNPd25Qcm9wZXJ0eSgnaGFzaCcpID8gcmUuaGFzaCA6IGhhc2g7XG4gICAgcGFyYW1zID0gcmUuaGFzT3duUHJvcGVydHkoJ3BhcmFtcycpID8gcmUucGFyYW1zIDogcGFyYW1zO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIC8vIHJlc29sdmVkIG5hbWVkIGRpcmVjdFxuICAgICAgdmFyIHRhcmdldFJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQodGFyZ2V0UmVjb3JkLCAoXCJyZWRpcmVjdCBmYWlsZWQ6IG5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2UgaWYgKHBhdGgpIHtcbiAgICAgIC8vIDEuIHJlc29sdmUgcmVsYXRpdmUgcmVkaXJlY3RcbiAgICAgIHZhciByYXdQYXRoID0gcmVzb2x2ZVJlY29yZFBhdGgocGF0aCwgcmVjb3JkKTtcbiAgICAgIC8vIDIuIHJlc29sdmUgcGFyYW1zXG4gICAgICB2YXIgcmVzb2x2ZWRQYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMsIChcInJlZGlyZWN0IHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyByYXdQYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIC8vIDMuIHJlbWF0Y2ggd2l0aCBleGlzdGluZyBxdWVyeSBhbmQgaGFzaFxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIHBhdGg6IHJlc29sdmVkUGF0aCxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBoYXNoOiBoYXNoXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGlhcyAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIG1hdGNoQXNcbiAgKSB7XG4gICAgdmFyIGFsaWFzZWRQYXRoID0gZmlsbFBhcmFtcyhtYXRjaEFzLCBsb2NhdGlvbi5wYXJhbXMsIChcImFsaWFzZWQgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIG1hdGNoQXMgKyBcIlxcXCJcIikpO1xuICAgIHZhciBhbGlhc2VkTWF0Y2ggPSBtYXRjaCh7XG4gICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgIHBhdGg6IGFsaWFzZWRQYXRoXG4gICAgfSk7XG4gICAgaWYgKGFsaWFzZWRNYXRjaCkge1xuICAgICAgdmFyIG1hdGNoZWQgPSBhbGlhc2VkTWF0Y2gubWF0Y2hlZDtcbiAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0gYWxpYXNlZE1hdGNoLnBhcmFtcztcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUoYWxpYXNlZFJlY29yZCwgbG9jYXRpb24pXG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlUm91dGUgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5yZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlY29yZCwgcmVkaXJlY3RlZEZyb20gfHwgbG9jYXRpb24pXG4gICAgfVxuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLm1hdGNoQXMpIHtcbiAgICAgIHJldHVybiBhbGlhcyhyZWNvcmQsIGxvY2F0aW9uLCByZWNvcmQubWF0Y2hBcylcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tLCByb3V0ZXIpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBhZGRSb3V0ZXM6IGFkZFJvdXRlc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGUgKFxuICByZWdleCxcbiAgcGF0aCxcbiAgcGFyYW1zXG4pIHtcbiAgdmFyIG0gPSBwYXRoLm1hdGNoKHJlZ2V4KTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IHJlZ2V4LmtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcbiAgICAgIHNldFN0YXRlS2V5KGUuc3RhdGUua2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxuICByb3V0ZXIsXG4gIHRvLFxuICBmcm9tLFxuICBpc1BvcFxuKSB7XG4gIGlmICghcm91dGVyLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJlaGF2aW9yID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gIGlmICghYmVoYXZpb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyB3YWl0IHVudGlsIHJlLXJlbmRlciBmaW5pc2hlcyBiZWZvcmUgc2Nyb2xsaW5nXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHZhciBzaG91bGRTY3JvbGwgPSBiZWhhdmlvcih0bywgZnJvbSwgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGwpO1xuICAgIGlmICghc2hvdWxkU2Nyb2xsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIHNob3VsZFNjcm9sbCA9PT0gJ29iamVjdCc7XG4gICAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNob3VsZFNjcm9sbC5zZWxlY3Rvcik7XG4gICAgICBpZiAoZWwpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnID8gc2hvdWxkU2Nyb2xsLm9mZnNldCA6IHt9O1xuICAgICAgICBvZmZzZXQgPSBub3JtYWxpemVPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwsIG9mZnNldCk7XG4gICAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2F2ZVNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICBwb3NpdGlvblN0b3JlW2tleV0gPSB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBvc2l0aW9uICgpIHtcbiAgdmFyIGtleSA9IGdldFN0YXRlS2V5KCk7XG4gIGlmIChrZXkpIHtcbiAgICByZXR1cm4gcG9zaXRpb25TdG9yZVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudFBvc2l0aW9uIChlbCwgb2Zmc2V0KSB7XG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGRvY1JlY3QgPSBkb2NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGVsUmVjdC5sZWZ0IC0gZG9jUmVjdC5sZWZ0IC0gb2Zmc2V0LngsXG4gICAgeTogZWxSZWN0LnRvcCAtIGRvY1JlY3QudG9wIC0gb2Zmc2V0LnlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUG9zaXRpb24gKG9iaikge1xuICByZXR1cm4gaXNOdW1iZXIob2JqLngpIHx8IGlzTnVtYmVyKG9iai55KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgeTogaXNOdW1iZXIob2JqLnkpID8gb2JqLnkgOiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPZmZzZXQgKG9iaikge1xuICByZXR1cm4ge1xuICAgIHg6IGlzTnVtYmVyKG9iai54KSA/IG9iai54IDogMCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBpc051bWJlciAodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInXG59XG5cbi8qICAqL1xuXG52YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSBpbkJyb3dzZXIgJiYgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKFxuICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxuICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5XG59KSgpO1xuXG4vLyB1c2UgVXNlciBUaW1pbmcgYXBpIChpZiBwcmVzZW50KSBmb3IgbW9yZSBhY2N1cmF0ZSBrZXkgcHJlY2lzaW9uXG52YXIgVGltZSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZVxuICA6IERhdGU7XG5cbnZhciBfa2V5ID0gZ2VuS2V5KCk7XG5cbmZ1bmN0aW9uIGdlbktleSAoKSB7XG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVLZXkgKCkge1xuICByZXR1cm4gX2tleVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZUtleSAoa2V5KSB7XG4gIF9rZXkgPSBrZXk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAvLyB0cnkuLi5jYXRjaCB0aGUgcHVzaFN0YXRlIGNhbGwgdG8gZ2V0IGFyb3VuZCBTYWZhcmlcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2tleSA9IGdlbktleSgpO1xuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlU3RhdGUgKHVybCkge1xuICBwdXNoU3RhdGUodXJsLCB0cnVlKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJ1blF1ZXVlIChxdWV1ZSwgZm4sIGNiKSB7XG4gIHZhciBzdGVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlW2luZGV4XSkge1xuICAgICAgICBmbihxdWV1ZVtpbmRleF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RlcCgwKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHZhciBoYXNBc3luYyA9IGZhbHNlO1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxuICAgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xuICAgICAgICBwZW5kaW5nKys7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIGlmIChyZXNvbHZlZERlZi5fX2VzTW9kdWxlICYmIHJlc29sdmVkRGVmLmRlZmF1bHQpIHtcbiAgICAgICAgICAgIHJlc29sdmVkRGVmID0gcmVzb2x2ZWREZWYuZGVmYXVsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc2F2ZSByZXNvbHZlZCBvbiBhc3luYyBmYWN0b3J5IGluIGNhc2UgaXQncyB1c2VkIGVsc2V3aGVyZVxuICAgICAgICAgIGRlZi5yZXNvbHZlZCA9IHR5cGVvZiByZXNvbHZlZERlZiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyByZXNvbHZlZERlZlxuICAgICAgICAgICAgOiBfVnVlLmV4dGVuZChyZXNvbHZlZERlZik7XG4gICAgICAgICAgbWF0Y2guY29tcG9uZW50c1trZXldID0gcmVzb2x2ZWREZWY7XG4gICAgICAgICAgcGVuZGluZy0tO1xuICAgICAgICAgIGlmIChwZW5kaW5nIDw9IDApIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICB2YXIgbXNnID0gXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQgXCIgKyBrZXkgKyBcIjogXCIgKyByZWFzb247XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBtc2cpO1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gaXNFcnJvcihyZWFzb24pXG4gICAgICAgICAgICAgID8gcmVhc29uXG4gICAgICAgICAgICAgIDogbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gZGVmKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5ldyBzeW50YXggaW4gVnVlIDIuM1xuICAgICAgICAgICAgdmFyIGNvbXAgPSByZXMuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXAgJiYgdHlwZW9mIGNvbXAudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjb21wLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghaGFzQXN5bmMpIHsgbmV4dCgpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdE1hcENvbXBvbmVudHMgKFxuICBtYXRjaGVkLFxuICBmblxuKSB7XG4gIHJldHVybiBmbGF0dGVuKG1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKFxuICAgICAgbS5jb21wb25lbnRzW2tleV0sXG4gICAgICBtLmluc3RhbmNlc1trZXldLFxuICAgICAgbSwga2V5XG4gICAgKTsgfSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4gKGFycikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKVxufVxuXG4vLyBpbiBXZWJwYWNrIDIsIHJlcXVpcmUuZW5zdXJlIG5vdyBhbHNvIHJldHVybnMgYSBQcm9taXNlXG4vLyBzbyB0aGUgcmVzb2x2ZS9yZWplY3QgZnVuY3Rpb25zIG1heSBnZXQgY2FsbGVkIGFuIGV4dHJhIHRpbWVcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xuLy8gcmV0dXJuIHRoYXQgUHJvbWlzZS5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoY2FsbGVkKSB7IHJldHVybiB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiBIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XG4gIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMucmVhZHlDYnMgPSBbXTtcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XG4gIHRoaXMuZXJyb3JDYnMgPSBbXTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgY2IoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xuICAgIGlmIChlcnJvckNiKSB7XG4gICAgICB0aGlzLnJlYWR5RXJyb3JDYnMucHVzaChlcnJvckNiKTtcbiAgICB9XG4gIH1cbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuZXJyb3JDYnMucHVzaChlcnJvckNiKTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5tYXRjaChsb2NhdGlvbiwgdGhpcy5jdXJyZW50KTtcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XG5cbiAgICAvLyBmaXJlIHJlYWR5IGNicyBvbmNlXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2Iocm91dGUpOyB9KTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAob25BYm9ydCkge1xuICAgICAgb25BYm9ydChlcnIpO1xuICAgIH1cbiAgICBpZiAoZXJyICYmICF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlFcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICAgIGlmICh0aGlzJDEuZXJyb3JDYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMkMS5lcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkFib3J0ICYmIG9uQWJvcnQoZXJyKTtcbiAgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gZmFsc2UgfHwgaXNFcnJvcih0bykpIHtcbiAgICAgICAgICAvLyBuZXh0KGZhbHNlKSAtPiBhYm9ydCBuYXZpZ2F0aW9uLCBlbnN1cmUgY3VycmVudCBVUkxcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xuICAgICAgICAgIGFib3J0KHRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHRvLnBhdGggPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICApKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgdG8ucmVwbGFjZSkge1xuICAgICAgICAgICAgdGhpcyQxLnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzJDEucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgICBuZXh0KHRvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYWJvcnQoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jdXJyZW50ID09PSByb3V0ZTsgfTtcbiAgICAvLyB3YWl0IHVudGlsIGFzeW5jIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkIGJlZm9yZVxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgdmFyIHF1ZXVlID0gZW50ZXJHdWFyZHMuY29uY2F0KHRoaXMkMS5yb3V0ZXIucmVzb2x2ZUhvb2tzKTtcbiAgICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5jdXJyZW50ID0gcm91dGU7XG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XG4gIHRoaXMucm91dGVyLmFmdGVySG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xuICBpZiAoIWJhc2UpIHtcbiAgICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcbiAgICAgIC8vIHN0cmlwIGZ1bGwgVVJMIG9yaWdpblxuICAgICAgYmFzZSA9IGJhc2UucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC9bXlxcL10rLywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJy8nO1xuICAgIH1cbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgaWYgKGJhc2UuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBiYXNlID0gJy8nICsgYmFzZTtcbiAgfVxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgcmV0dXJuIGJhc2UucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUXVldWUgKFxuICBjdXJyZW50LFxuICBuZXh0XG4pIHtcbiAgdmFyIGk7XG4gIHZhciBtYXggPSBNYXRoLm1heChjdXJyZW50Lmxlbmd0aCwgbmV4dC5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVkOiBuZXh0LnNsaWNlKDAsIGkpLFxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcbiAgICBkZWFjdGl2YXRlZDogY3VycmVudC5zbGljZShpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZHMgKFxuICByZWNvcmRzLFxuICBuYW1lLFxuICBiaW5kLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIGd1YXJkcyA9IGZsYXRNYXBDb21wb25lbnRzKHJlY29yZHMsIGZ1bmN0aW9uIChkZWYsIGluc3RhbmNlLCBtYXRjaCwga2V5KSB7XG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XG4gICAgaWYgKGd1YXJkKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShndWFyZClcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXG4gICAgICAgIDogYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZsYXR0ZW4ocmV2ZXJzZSA/IGd1YXJkcy5yZXZlcnNlKCkgOiBndWFyZHMpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZCAoXG4gIGRlZixcbiAga2V5XG4pIHtcbiAgaWYgKHR5cGVvZiBkZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cbiAgICBkZWYgPSBfVnVlLmV4dGVuZChkZWYpO1xuICB9XG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoZGVhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUxlYXZlJywgYmluZEd1YXJkLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VXBkYXRlSG9va3MgKHVwZGF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHModXBkYXRlZCwgJ2JlZm9yZVJvdXRlVXBkYXRlJywgYmluZEd1YXJkKVxufVxuXG5mdW5jdGlvbiBiaW5kR3VhcmQgKGd1YXJkLCBpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRSb3V0ZUd1YXJkICgpIHtcbiAgICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RW50ZXJHdWFyZHMgKFxuICBhY3RpdmF0ZWQsXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlRW50ZXInLCBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICByZXR1cm4gYmluZEVudGVyR3VhcmQoZ3VhcmQsIG1hdGNoLCBrZXksIGNicywgaXNWYWxpZClcbiAgfSlcbn1cblxuZnVuY3Rpb24gYmluZEVudGVyR3VhcmQgKFxuICBndWFyZCxcbiAgbWF0Y2gsXG4gIGtleSxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcbiAgICByZXR1cm4gZ3VhcmQodG8sIGZyb20sIGZ1bmN0aW9uIChjYikge1xuICAgICAgbmV4dChjYik7XG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNicy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAjNzUwXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXG4gICAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgYXQgdGhpcyB0aW1lLlxuICAgICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBwb2xsIGZvciByZWdpc3RyYXRpb24gdW50aWwgY3VycmVudCByb3V0ZVxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICBwb2xsKGNiLCBtYXRjaC5pbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcG9sbCAoXG4gIGNiLCAvLyBzb21laG93IGZsb3cgY2Fubm90IGluZmVyIHRoaXMgaXMgYSBmdW5jdGlvblxuICBpbnN0YW5jZXMsXG4gIGtleSxcbiAgaXNWYWxpZFxuKSB7XG4gIGlmIChpbnN0YW5jZXNba2V5XSkge1xuICAgIGNiKGluc3RhbmNlc1trZXldKTtcbiAgfSBlbHNlIGlmIChpc1ZhbGlkKCkpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHBvbGwoY2IsIGluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICB9LCAxNik7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIVE1MNUhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG5cbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG5cbiAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhUTUw1SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSFRNTDVIaXN0b3J5O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICBpZiAoZ2V0TG9jYXRpb24odGhpcy5iYXNlKSAhPT0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNsZWFuUGF0aCh0aGlzLmJhc2UgKyB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpO1xuICAgICAgcHVzaCA/IHB1c2hTdGF0ZShjdXJyZW50KSA6IHJlcGxhY2VTdGF0ZShjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRMb2NhdGlvbih0aGlzLmJhc2UpXG4gIH07XG5cbiAgcmV0dXJuIEhUTUw1SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbiAoYmFzZSkge1xuICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXG59XG5cbi8qICAqL1xuXG5cbnZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIYXNoSGlzdG9yeSAocm91dGVyLCBiYXNlLCBmYWxsYmFjaykge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcbiAgICBpZiAoZmFsbGJhY2sgJiYgY2hlY2tGYWxsYmFjayh0aGlzLmJhc2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZW5zdXJlU2xhc2goKTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhhc2hIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XG5cbiAgLy8gdGhpcyBpcyBkZWxheWVkIHVudGlsIHRoZSBhcHAgbW91bnRzXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0SGFzaCgpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuZnVsbFBhdGg7XG4gICAgaWYgKGdldEhhc2goKSAhPT0gY3VycmVudCkge1xuICAgICAgcHVzaCA/IHB1c2hIYXNoKGN1cnJlbnQpIDogcmVwbGFjZUhhc2goY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRIYXNoKClcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gY2hlY2tGYWxsYmFjayAoYmFzZSkge1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihiYXNlKTtcbiAgaWYgKCEvXlxcLyMvLnRlc3QobG9jYXRpb24pKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoXG4gICAgICBjbGVhblBhdGgoYmFzZSArICcvIycgKyBsb2NhdGlvbilcbiAgICApO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlU2xhc2ggKCkge1xuICB2YXIgcGF0aCA9IGdldEhhc2goKTtcbiAgaWYgKHBhdGguY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJlcGxhY2VIYXNoKCcvJyArIHBhdGgpO1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaCAoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBpbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc2xpY2UoaW5kZXggKyAxKVxufVxuXG5mdW5jdGlvbiBwdXNoSGFzaCAocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoIChwYXRoKSB7XG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHZhciBiYXNlID0gaSA+PSAwID8gaHJlZi5zbGljZSgwLCBpKSA6IGhyZWY7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKChiYXNlICsgXCIjXCIgKyBwYXRoKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5pbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgQWJzdHJhY3RIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXggKyAxKS5jb25jYXQocm91dGUpO1xuICAgICAgdGhpcyQxLmluZGV4Kys7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4KS5jb25jYXQocm91dGUpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB0YXJnZXRJbmRleCA9IHRoaXMuaW5kZXggKyBuO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcm91dGUgPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XTtcbiAgICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcbiAgICAvLyBub29wXG4gIH07XG5cbiAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG4vKiAgKi9cblxudmFyIFZ1ZVJvdXRlciA9IGZ1bmN0aW9uIFZ1ZVJvdXRlciAob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLmFwcCA9IG51bGw7XG4gIHRoaXMuYXBwcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmJlZm9yZUhvb2tzID0gW107XG4gIHRoaXMucmVzb2x2ZUhvb2tzID0gW107XG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xuICB0aGlzLm1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKG9wdGlvbnMucm91dGVzIHx8IFtdLCB0aGlzKTtcblxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XG4gIHRoaXMuZmFsbGJhY2sgPSBtb2RlID09PSAnaGlzdG9yeScgJiYgIXN1cHBvcnRzUHVzaFN0YXRlICYmIG9wdGlvbnMuZmFsbGJhY2sgIT09IGZhbHNlO1xuICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgIG1vZGUgPSAnaGFzaCc7XG4gIH1cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcbiAgfVxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2hpc3RvcnknOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdhYnN0cmFjdCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhc3NlcnQoZmFsc2UsIChcImludmFsaWQgbW9kZTogXCIgKyBtb2RlKSk7XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGN1cnJlbnRSb3V0ZToge30gfTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICByZWRpcmVjdGVkRnJvbVxuKSB7XG4gIHJldHVybiB0aGlzLm1hdGNoZXIubWF0Y2gocmF3LCBjdXJyZW50LCByZWRpcmVjdGVkRnJvbSlcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5jdXJyZW50Um91dGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5jdXJyZW50XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChhcHAgLyogVnVlIGNvbXBvbmVudCBpbnN0YW5jZSAqLykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0KFxuICAgIGluc3RhbGwuaW5zdGFsbGVkLFxuICAgIFwibm90IGluc3RhbGxlZC4gTWFrZSBzdXJlIHRvIGNhbGwgYFZ1ZS51c2UoVnVlUm91dGVyKWAgXCIgK1xuICAgIFwiYmVmb3JlIGNyZWF0aW5nIHJvb3QgaW5zdGFuY2UuXCJcbiAgKTtcblxuICB0aGlzLmFwcHMucHVzaChhcHApO1xuXG4gIC8vIG1haW4gYXBwIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gIGlmICh0aGlzLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5hcHAgPSBhcHA7XG5cbiAgdmFyIGhpc3RvcnkgPSB0aGlzLmhpc3Rvcnk7XG5cbiAgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIVE1MNUhpc3RvcnkpIHtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfSBlbHNlIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSGFzaEhpc3RvcnkpIHtcbiAgICB2YXIgc2V0dXBIYXNoTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBoaXN0b3J5LnNldHVwTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBoaXN0b3J5LnRyYW5zaXRpb25UbyhcbiAgICAgIGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCksXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lcixcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyXG4gICAgKTtcbiAgfVxuXG4gIGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIHRoaXMkMS5hcHBzLmZvckVhY2goZnVuY3Rpb24gKGFwcCkge1xuICAgICAgYXBwLl9yb3V0ZSA9IHJvdXRlO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlRWFjaCA9IGZ1bmN0aW9uIGJlZm9yZUVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5iZWZvcmVIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZVJlc29sdmUgPSBmdW5jdGlvbiBiZWZvcmVSZXNvbHZlIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMucmVzb2x2ZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gYWZ0ZXJFYWNoIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYWZ0ZXJIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xuICB0aGlzLmhpc3Rvcnkub25SZWFkeShjYiwgZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vbkVycm9yKGVycm9yQ2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnB1c2gobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgdGhpcy5oaXN0b3J5LnJlcGxhY2UobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gIHRoaXMuaGlzdG9yeS5nbyhuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIGJhY2sgKCkge1xuICB0aGlzLmdvKC0xKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xuICB0aGlzLmdvKDEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nZXRNYXRjaGVkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGdldE1hdGNoZWRDb21wb25lbnRzICh0bykge1xuICB2YXIgcm91dGUgPSB0b1xuICAgID8gdG8ubWF0Y2hlZFxuICAgICAgPyB0b1xuICAgICAgOiB0aGlzLnJlc29sdmUodG8pLnJvdXRlXG4gICAgOiB0aGlzLmN1cnJlbnRSb3V0ZTtcbiAgaWYgKCFyb3V0ZSkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHJvdXRlLm1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxuICAgIH0pXG4gIH0pKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAoXG4gIHRvLFxuICBjdXJyZW50LFxuICBhcHBlbmRcbikge1xuICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihcbiAgICB0byxcbiAgICBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50LFxuICAgIGFwcGVuZCxcbiAgICB0aGlzXG4gICk7XG4gIHZhciByb3V0ZSA9IHRoaXMubWF0Y2gobG9jYXRpb24sIGN1cnJlbnQpO1xuICB2YXIgZnVsbFBhdGggPSByb3V0ZS5yZWRpcmVjdGVkRnJvbSB8fCByb3V0ZS5mdWxsUGF0aDtcbiAgdmFyIGJhc2UgPSB0aGlzLmhpc3RvcnkuYmFzZTtcbiAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGJhc2UsIGZ1bGxQYXRoLCB0aGlzLm1vZGUpO1xuICByZXR1cm4ge1xuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICByb3V0ZTogcm91dGUsXG4gICAgaHJlZjogaHJlZixcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIG5vcm1hbGl6ZWRUbzogbG9jYXRpb24sXG4gICAgcmVzb2x2ZWQ6IHJvdXRlXG4gIH1cbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWRkUm91dGVzID0gZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgdGhpcy5tYXRjaGVyLmFkZFJvdXRlcyhyb3V0ZXMpO1xuICBpZiAodGhpcy5oaXN0b3J5LmN1cnJlbnQgIT09IFNUQVJUKSB7XG4gICAgdGhpcy5oaXN0b3J5LnRyYW5zaXRpb25Ubyh0aGlzLmhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVnVlUm91dGVyLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbmZ1bmN0aW9uIHJlZ2lzdGVySG9vayAobGlzdCwgZm4pIHtcbiAgbGlzdC5wdXNoKGZuKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IGxpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGkgPiAtMSkgeyBsaXN0LnNwbGljZShpLCAxKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhyZWYgKGJhc2UsIGZ1bGxQYXRoLCBtb2RlKSB7XG4gIHZhciBwYXRoID0gbW9kZSA9PT0gJ2hhc2gnID8gJyMnICsgZnVsbFBhdGggOiBmdWxsUGF0aDtcbiAgcmV0dXJuIGJhc2UgPyBjbGVhblBhdGgoYmFzZSArICcvJyArIHBhdGgpIDogcGF0aFxufVxuXG5WdWVSb3V0ZXIuaW5zdGFsbCA9IGluc3RhbGw7XG5WdWVSb3V0ZXIudmVyc2lvbiA9ICcyLjcuMCc7XG5cbmlmIChpbkJyb3dzZXIgJiYgd2luZG93LlZ1ZSkge1xuICB3aW5kb3cuVnVlLnVzZShWdWVSb3V0ZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBWdWVSb3V0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvLjIuNy4wQHZ1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n");

/***/ }),

/***/ 2:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, global) {/*!\n * Vue.js v2.4.2\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n\n\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction isUndef(v) {\n  return v === undefined || v === null;\n}\n\nfunction isDef(v) {\n  return v !== undefined && v !== null;\n}\n\nfunction isTrue(v) {\n  return v === true;\n}\n\nfunction isFalse(v) {\n  return v === false;\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive(value) {\n  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject(obj) {\n  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject(obj) {\n  return _toString.call(obj) === '[object Object]';\n}\n\nfunction isRegExp(v) {\n  return _toString.call(v) === '[object RegExp]';\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex(val) {\n  var n = parseFloat(val);\n  return n >= 0 && Math.floor(n) === n && isFinite(val);\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString(val) {\n  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber(val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n;\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap(str, expectsLowerCase) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? function (val) {\n    return map[val.toLowerCase()];\n  } : function (val) {\n    return map[val];\n  };\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove(arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) {\n    return c ? c.toUpperCase() : '';\n  });\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind(fn, ctx) {\n  function boundFn(a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn;\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray(list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret;\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to;\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject(arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res;\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop(a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function no(a, b, c) {\n  return false;\n};\n\n/**\n * Return same value\n */\nvar identity = function identity(_) {\n  return _;\n};\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys(modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || []);\n  }, []).join(',');\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i]);\n        });\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key]);\n        });\n      } else {\n        /* istanbul ignore next */\n        return false;\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false;\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n}\n\nfunction looseIndexOf(arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once(fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\n\nvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n};\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved(str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F;\n}\n\n/**\n * Define a property.\n */\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath(path) {\n  if (bailRE.test(path)) {\n    return;\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) {\n        return;\n      }\n      obj = obj[segments[i]];\n    }\n    return obj;\n  };\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = null; // work around flow check\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function classify(str) {\n    return str.replace(classifyRE, function (c) {\n      return c.toUpperCase();\n    }).replace(/[-_]/g, '');\n  };\n\n  warn = function warn(msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && !config.silent) {\n      console.error(\"[Vue warn]: \" + msg + trace);\n    }\n  };\n\n  tip = function tip(msg, vm) {\n    if (hasConsole && !config.silent) {\n      console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n    }\n  };\n\n  formatComponentName = function formatComponentName(vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>';\n    }\n    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n  };\n\n  var repeat = function repeat(str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) {\n        res += str;\n      }\n      if (n > 1) {\n        str += str;\n      }\n      n >>= 1;\n    }\n    return res;\n  };\n\n  var generateComponentTrace = function generateComponentTrace(vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue;\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n        return \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n      }).join('\\n');\n    } else {\n      return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n    }\n  };\n}\n\n/*  */\n\nfunction handleError(err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefix has a \"watch\" function on Object.prototype...\nvar nativeWatch = {}.watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', {\n      get: function get() {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    }); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function isServerRendering() {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer;\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative(Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n}\n\nvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function logError(err) {\n      console.error(err);\n    };\n    timerFunc = function timerFunc() {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]')) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function timerFunc() {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function timerFunc() {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick(cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      });\n    }\n  };\n}();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = function () {\n    function Set() {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has(key) {\n      return this.set[key] === true;\n    };\n    Set.prototype.add = function add(key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear() {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }();\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep() {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub(sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub(sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend() {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify() {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget(_target) {\n  if (Dep.target) {\n    targetStack.push(Dep.target);\n  }\n  Dep.target = _target;\n}\n\nfunction popTarget() {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator() {\n    var args = [],\n        len = arguments.length;\n    while (len--) {\n      args[len] = arguments[len];\n    }var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2);\n        break;\n    }\n    if (inserted) {\n      ob.observeArray(inserted);\n    }\n    // notify change\n    ob.dep.notify();\n    return result;\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto ? protoAugment : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk(obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray(items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment(target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment(target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe(value, asRootData) {\n  if (!isObject(value)) {\n    return;\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1(obj, key, val, customSetter, shallow) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || newVal !== newVal && value !== value) {\n        return;\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set(target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val;\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n    return val;\n  }\n  if (!ob) {\n    target[key] = val;\n    return val;\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val;\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del(target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return;\n  }\n  var ob = target.__ob__;\n  if (target._isVue || ob && ob.vmCount) {\n    process.env.NODE_ENV !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n    return;\n  }\n  if (!hasOwn(target, key)) {\n    return;\n  }\n  delete target[key];\n  if (!ob) {\n    return;\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray(value) {\n  for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n    }\n    return defaultStrat(parent, child);\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData(to, from) {\n  if (!from) {\n    return to;\n  }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to;\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn(parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal;\n    }\n    if (!parentVal) {\n      return childVal;\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn() {\n      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);\n    };\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn() {\n      // instance merge\n      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData);\n      } else {\n        return defaultData;\n      }\n    };\n  }\n}\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\n      return parentVal;\n    }\n    return mergeDataOrFn.call(this, parentVal, childVal);\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm);\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook(parentVal, childVal) {\n  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets(parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal ? extend(res, childVal) : res;\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) {\n    parentVal = undefined;\n  }\n  if (childVal === nativeWatch) {\n    childVal = undefined;\n  }\n  /* istanbul ignore if */\n  if (!childVal) {\n    return Object.create(parentVal || null);\n  }\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n  }\n  return ret;\n};\n\n/**\n * Other object hashes.\n */\nstrats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {\n  if (!parentVal) {\n    return childVal;\n  }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) {\n    extend(ret, childVal);\n  }\n  return ret;\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function defaultStrat(parentVal, childVal) {\n  return childVal === undefined ? parentVal : childVal;\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents(options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps(options) {\n  var props = options.props;\n  if (!props) {\n    return;\n  }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val) ? val : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject(options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives(options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions(parent, child, vm) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeInject(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options;\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset(options, type, id, warnMissing) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return;\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) {\n    return assets[id];\n  }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) {\n    return assets[camelizedId];\n  }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) {\n    return assets[PascalCaseId];\n  }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n  }\n  return res;\n}\n\n/*  */\n\nfunction validateProp(key, propOptions, propsData, vm) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value;\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue(vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined;\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n    return vm._props[key];\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp(prop, name, value, vm, absent) {\n  if (prop.required && absent) {\n    warn('Missing required prop: \"' + name + '\"', vm);\n    return;\n  }\n  if (value == null && !prop.required) {\n    return;\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n    return;\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType(value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  };\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType(fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : '';\n}\n\nfunction isType(type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type);\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true;\n    }\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n    mark = function mark(tag) {\n      return perf.mark(tag);\n    };\n    measure = function measure(name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function warnNonPresent(target, key) {\n    warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + \"referenced during render. Make sure to declare reactive data \" + \"properties in the data option.\", target);\n  };\n\n  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set(target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n          return false;\n        } else {\n          target[key] = value;\n          return true;\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has(target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed;\n    }\n  };\n\n  var getHandler = {\n    get: function get(target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key];\n    }\n  };\n\n  initProxy = function initProxy(vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance;\n};\n\nObject.defineProperties(VNode.prototype, prototypeAccessors);\n\nvar createEmptyVNode = function createEmptyVNode(text) {\n  if (text === void 0) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node;\n};\n\nfunction createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val));\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode(vnode) {\n  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned;\n}\n\nfunction cloneVNodes(vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res;\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  };\n});\n\nfunction createFnInvoker(fns) {\n  function invoker() {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments);\n    }\n  }\n  invoker.fns = fns;\n  return invoker;\n}\n\nfunction updateListeners(on, oldOn, add, remove$$1, vm) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook(def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook() {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return;\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n          tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n        }\n      }\n      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res;\n}\n\nfunction checkProp(res, hash, key, altKey, preserve) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true;\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren(children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children);\n    }\n  }\n  return children;\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren(children) {\n  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n}\n\nfunction isTextNode(node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n}\n\nfunction normalizeArrayChildren(children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') {\n      continue;\n    }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res;\n}\n\n/*  */\n\nfunction ensureCtor(comp, base) {\n  if (comp.__esModule && comp.default) {\n    comp = comp.default;\n  }\n  return isObject(comp) ? base.extend(comp) : comp;\n}\n\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node;\n}\n\nfunction resolveAsyncComponent(factory, baseCtor, context) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp;\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved;\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp;\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function forceRender() {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(process.env.NODE_ENV !== 'production' ? \"timeout (\" + res.timeout + \"ms)\" : null);\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading ? factory.loadingComp : factory.resolved;\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild(children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c;\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents(vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add(event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1(event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners(vm, listeners, oldListeners) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin(Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on() {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm;\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm;\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm;\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm;\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm;\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break;\n      }\n    }\n    return vm;\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, \"event handler for \\\"\" + event + \"\\\"\");\n        }\n      }\n    }\n    return vm;\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots(children, context) {\n  var slots = {};\n  if (!children) {\n    return slots;\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {\n      var name = child.data.slot;\n      var slot = slots[name] || (slots[name] = []);\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots;\n}\n\nfunction isWhitespace(node) {\n  return node.isComment || node.text === ' ';\n}\n\nfunction resolveScopedSlots(fns, // see flow/vnode\nres) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle(vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n      , vm.$options._parentElm, vm.$options._refElm);\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return;\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n  };\n}\n\nfunction mountComponent(vm, el, hydrating) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n      } else {\n        warn('Failed to mount component: template or render function not defined.', vm);\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function updateComponent() {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure(name + \" render\", startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure(name + \" patch\", startTag, endTag);\n    };\n  } else {\n    updateComponent = function updateComponent() {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm;\n}\n\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(renderChildren || // has new static slots\n  vm.$options._renderChildren || // has old static slots\n  parentVnode.data.scopedSlots || // has new scoped slots\n  vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) {\n    // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listensers hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data && parentVnode.data.attrs;\n  vm.$listeners = listeners;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree(vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction activateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  } else if (vm._directInactive) {\n    return;\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent(vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return;\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook(vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, hook + \" hook\");\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState() {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue() {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) {\n    return a.id - b.id;\n  });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n        break;\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks(queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent(vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher(watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher(vm, expOrFn, cb, options) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n    }\n  }\n  this.value = this.lazy ? undefined : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get() {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n    } else {\n      throw e;\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value;\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep(dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update() {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run() {\n  if (this.active) {\n    var value = this.get();\n    if (value !== this.value ||\n    // Deep watchers and watchers on Object/Arrays should fire even\n    // when the value is the same, because the value may\n    // have mutated.\n    isObject(value) || this.deep) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate() {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend() {\n  var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown() {\n  var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse(val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse(val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if (!isA && !isObject(val) || !Object.isExtensible(val)) {\n    return;\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return;\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) {\n      _traverse(val[i], seen);\n    }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) {\n      _traverse(val[keys[i]], seen);\n    }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy(target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key];\n  };\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState(vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) {\n    initProps(vm, opts.props);\n  }\n  if (opts.methods) {\n    initMethods(vm, opts.methods);\n  }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) {\n    initComputed(vm, opts.computed);\n  }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction checkOptionType(vm, name) {\n  var option = vm.$options[name];\n  if (!isPlainObject(option)) {\n    warn(\"component option \\\"\" + name + \"\\\" should be an object.\", vm);\n  }\n}\n\nfunction initProps(vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function loop(key) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n        warn(\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) {\n    loop(key);\n  }observerState.shouldConvert = true;\n}\n\nfunction initData(vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\"method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData(data, vm) {\n  try {\n    return data.call(vm);\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {};\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed(vm, computed) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n  }\n  if (process.env.NODE_ENV !== 'production' && sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter(key) {\n  return function computedGetter() {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value;\n    }\n  };\n}\n\nfunction initMethods(vm, methods) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\"method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n      }\n    }\n  }\n}\n\nfunction initWatch(vm, watch) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, keyOrFn, handler, options) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options);\n}\n\nfunction stateMixin(Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data;\n  };\n  var propsDef = {};\n  propsDef.get = function () {\n    return this._props;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (expOrFn, cb, options) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options);\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn() {\n      watcher.teardown();\n    };\n  };\n}\n\n/*  */\n\nfunction initProvide(vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n  }\n}\n\nfunction initInjections(vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject(inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break;\n        }\n        source = source.$parent;\n      }\n      if (process.env.NODE_ENV !== 'production' && !source) {\n        warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n      }\n    }\n    return result;\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent(Ctor, propsData, data, context, children) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) {\n      mergeProps(props, data.attrs);\n    }\n    if (isDef(data.props)) {\n      mergeProps(props, data.props);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function h(a, b, c, d) {\n    return createElement(_context, a, b, c, d, true);\n  };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function slots() {\n      return resolveSlots(children, context);\n    }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode;\n}\n\nfunction mergeProps(to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init(vnode, hydrating, parentElm, refElm) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch(oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(child, options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n    );\n  },\n\n  insert: function insert(vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy(vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent(Ctor, data, context, children, tag) {\n  if (isUndef(Ctor)) {\n    return;\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn(\"Invalid Component definition: \" + String(Ctor), context);\n    }\n    return;\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children);\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\n  return vnode;\n}\n\nfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\nparent, // activeInstance in lifecycle state\nparentElm, refElm) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options);\n}\n\nfunction mergeHooks(data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1(one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  };\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel(options, data) {\n  var prop = options.model && options.model.prop || 'value';\n  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  if (isDef(data) && isDef(data.__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n    return createEmptyVNode();\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode();\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) && typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) {\n      applyNS(vnode, ns);\n    }\n    return vnode;\n  } else {\n    return createEmptyVNode();\n  }\n}\n\nfunction applyNS(vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList(val, render) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    ret._isVList = true;\n  }\n  return ret;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot(name, fallback, props, bindObject) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) {\n    // scoped slot\n    props = props || {};\n    if (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    return scopedSlotFn(props) || fallback;\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter(id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity;\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes(eventKeyCode, key, builtInAlias) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1;\n  } else {\n    return keyCodes !== eventKeyCode;\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function loop(key) {\n        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[\"update:\" + key] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) {\n        loop(key);\n      }\n    }\n  }\n  return data;\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic(index, isInFor) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, \"__static__\" + index, false);\n  return tree;\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce(tree, index, key) {\n  markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n  return tree;\n}\n\nfunction markStatic(tree, key, isOnce) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], key + \"_\" + i, isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode(node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners(data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn('v-on without argument expects an Object value', this);\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(ours, existing) : ours;\n      }\n    }\n  }\n  return data;\n}\n\n/*  */\n\nfunction initRender(vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, false);\n  };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) {\n    return createElement(vm, a, b, c, d, true);\n  };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);\n  }\n}\n\nfunction renderMixin(Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode;\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n  Vue.prototype._g = bindObjectListeners;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin(Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + vm._uid;\n      endTag = \"vue-perf-end:\" + vm._uid;\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(vm._name + \" init\", startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent(vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions(Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options;\n}\n\nfunction resolveModifiedOptions(Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) {\n        modified = {};\n      }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified;\n}\n\nfunction dedupe(latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res;\n  } else {\n    return latest;\n  }\n}\n\nfunction Vue$3(options) {\n  if (process.env.NODE_ENV !== 'production' && !(this instanceof Vue$3)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse(Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this;\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this;\n  };\n}\n\n/*  */\n\nfunction initMixin$1(Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this;\n  };\n}\n\n/*  */\n\nfunction initExtend(Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId];\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n      }\n    }\n\n    var Sub = function VueComponent(options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(Super.options, extendOptions);\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub;\n  };\n}\n\nfunction initProps$1(Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1(Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters(Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id];\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition;\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp, Array];\n\nfunction getComponentName(opts) {\n  return opts && (opts.Ctor.options.name || opts.tag);\n}\n\nfunction matches(pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1;\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1;\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction pruneCache(cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry(vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created() {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed() {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include(val) {\n      pruneCache(this.cache, this._vnode, function (name) {\n        return matches(val, name);\n      });\n    },\n    exclude: function exclude(val) {\n      pruneCache(this.cache, this._vnode, function (name) {\n        return !matches(val, name);\n      });\n    }\n  },\n\n  render: function render() {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {\n        return vnode;\n      }\n      var key = vnode.key == null\n      // same constructor may get registered as different local components\n      // so cid alone is not enough (#3269)\n      ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode;\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI(Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () {\n    return config;\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn('Do not replace the Vue.config object, set individual fields instead.');\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get() {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext;\n  }\n});\n\nVue$3.version = '2.4.2';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function mustUseProp(tag, type, attr) {\n  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function isXlink(name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n};\n\nvar getXlinkProp = function getXlinkProp(name) {\n  return isXlink(name) ? name.slice(6, name.length) : '';\n};\n\nvar isFalsyAttrValue = function isFalsyAttrValue(val) {\n  return val == null || val === false;\n};\n\n/*  */\n\nfunction genClassForVnode(vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class);\n}\n\nfunction mergeClassData(child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class) ? [child.class, parent.class] : parent.class\n  };\n}\n\nfunction renderClass(staticClass, dynamicClass) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass));\n  }\n  /* istanbul ignore next */\n  return '';\n}\n\nfunction concat(a, b) {\n  return a ? b ? a + ' ' + b : a : b || '';\n}\n\nfunction stringifyClass(value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value);\n  }\n  if (isObject(value)) {\n    return stringifyObject(value);\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  /* istanbul ignore next */\n  return '';\n}\n\nfunction stringifyArray(value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) {\n        res += ' ';\n      }\n      res += stringified;\n    }\n  }\n  return res;\n}\n\nfunction stringifyObject(value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) {\n        res += ' ';\n      }\n      res += key;\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\nvar isPreTag = function isPreTag(tag) {\n  return tag === 'pre';\n};\n\nvar isReservedTag = function isReservedTag(tag) {\n  return isHTMLTag(tag) || isSVG(tag);\n};\n\nfunction getTagNamespace(tag) {\n  if (isSVG(tag)) {\n    return 'svg';\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math';\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement(tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true;\n  }\n  if (isReservedTag(tag)) {\n    return false;\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag];\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n  } else {\n    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query(el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + el);\n      return document.createElement('div');\n    }\n    return selected;\n  } else {\n    return el;\n  }\n}\n\n/*  */\n\nfunction createElement$1(tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm;\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm;\n}\n\nfunction createElementNS(namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName);\n}\n\nfunction createTextNode(text) {\n  return document.createTextNode(text);\n}\n\nfunction createComment(text) {\n  return document.createComment(text);\n}\n\nfunction insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild(node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild(node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode(node) {\n  return node.parentNode;\n}\n\nfunction nextSibling(node) {\n  return node.nextSibling;\n}\n\nfunction tagName(node) {\n  return node.tagName;\n}\n\nfunction setTextContent(node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute(node, key, val) {\n  node.setAttribute(key, val);\n}\n\nvar nodeOps = Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create(_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update(oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy(vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef(vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) {\n    return;\n  }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType(a, b) {\n  if (a.tag !== 'input') {\n    return true;\n  }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB;\n}\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) {\n      map[key] = i;\n    }\n  }\n  return map;\n}\n\nfunction createPatchFunction(backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt(elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n  }\n\n  function createRmCb(childElm, listeners) {\n    function remove$$1() {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1;\n  }\n\n  function removeNode(el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return;\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n        }\n      }\n      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true;\n      }\n    }\n  }\n\n  function initComponent(vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break;\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert(parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren(vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable(vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag);\n  }\n\n  function invokeCreateHooks(vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) {\n        i.create(emptyNode, vnode);\n      }\n      if (isDef(i.insert)) {\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope(vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook(vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n        i(vnode);\n      }\n      for (i = 0; i < cbs.destroy.length; ++i) {\n        cbs.destroy[i](vnode);\n      }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else {\n          // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook(vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) {\n        // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) {\n        // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) {\n          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) {\n          // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return;\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return;\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return;\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) {\n        cbs.update[i](oldVnode, vnode);\n      }\n      if (isDef(i = data.hook) && isDef(i = i.update)) {\n        i(oldVnode, vnode);\n      }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) {\n          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n        }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n        i(oldVnode, vnode);\n      }\n    }\n  }\n\n  function invokeInsertHook(vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate(elm, vnode, insertedVnodeQueue) {\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.elm = elm;\n      vnode.isAsyncPlaceholder = true;\n      return true;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false;\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) {\n        i(vnode, true /* hydrating */);\n      }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true;\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break;\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined' && !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false;\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break;\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true;\n  }\n\n  function assertNodeMatch(node, vnode) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3);\n    }\n  }\n\n  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) {\n        invokeDestroyHook(oldVnode);\n      }\n      return;\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode;\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(vnode, insertedVnodeQueue,\n        // extremely rare edge case: do not insert if old element is in a\n        // leaving transition. Only happens when combining transition +\n        // keep-alive + HOCs. (#4590)\n        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm;\n  };\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives(vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives(oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update(oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function callInsert() {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1(dirs, vm) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res;\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res;\n}\n\nfunction getRawDirName(dir) {\n  return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n}\n\nfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n    }\n  }\n}\n\nvar baseModules = [ref, directives];\n\n/*  */\n\nfunction updateAttrs(oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return;\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return;\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr(el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass(oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n    return;\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters(exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) {\n        inSingle = false;\n      }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) {\n        inDouble = false;\n      }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) {\n        inTemplateString = false;\n      }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) {\n        inRegex = false;\n      }\n    } else if (c === 0x7C && // pipe\n    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22:\n          inDouble = true;break; // \"\n        case 0x27:\n          inSingle = true;break; // '\n        case 0x60:\n          inTemplateString = true;break; // `\n        case 0x28:\n          paren++;break; // (\n        case 0x29:\n          paren--;break; // )\n        case 0x5B:\n          square++;break; // [\n        case 0x5D:\n          square--;break; // ]\n        case 0x7B:\n          curly++;break; // {\n        case 0x7D:\n          curly--;break; // }\n      }\n      if (c === 0x2f) {\n        // /\n        var j = i - 1;\n        var p = void 0;\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') {\n            break;\n          }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter() {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression;\n}\n\nfunction wrapFilter(exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n  }\n}\n\n/*  */\n\nfunction baseWarn(msg) {\n  console.error(\"[Vue compiler]: \" + msg);\n}\n\nfunction pluckModuleFunction(modules, key) {\n  return modules ? modules.map(function (m) {\n    return m[key];\n  }).filter(function (_) {\n    return _;\n  }) : [];\n}\n\nfunction addProp(el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr(el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective(el, name, rawName, value, arg, modifiers) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler(el, name, value, modifiers, important, warn) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {\n    warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr(el, name, getStatic) {\n  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue);\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue);\n    }\n  }\n}\n\nfunction getAndRemoveAttr(el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break;\n      }\n    }\n  }\n  return val;\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel(el, value, modifiers) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: \"(\" + value + \")\",\n    expression: \"\\\"\" + value + \"\\\"\",\n    callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode(value, assignment) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return value + \"=\" + assignment;\n  } else {\n    return \"$set(\" + modelRs.exp + \", \" + modelRs.idx + \", \" + assignment + \")\";\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel(val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    };\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  };\n}\n\nfunction next() {\n  return str.charCodeAt(++index$1);\n}\n\nfunction eof() {\n  return index$1 >= len;\n}\n\nfunction isStringStart(chr) {\n  return chr === 0x22 || chr === 0x27;\n}\n\nfunction parseBracket(chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue;\n    }\n    if (chr === 0x5B) {\n      inBracket++;\n    }\n    if (chr === 0x5D) {\n      inBracket--;\n    }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break;\n    }\n  }\n}\n\nfunction parseString(chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model(el, dir, _warn) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" + \"v-model does not support dynamic input types. Use v-if branches instead.\");\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false;\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false;\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n  }\n\n  // ensure runtime directive metadata\n  return true;\n}\n\nfunction genCheckboxModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n}\n\nfunction genRadioModel(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n  addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect(el, value, modifiers) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel(el, value, modifiers) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', \"(\" + value + \")\");\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents(on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1(event, _handler, once$$1, capture, passive) {\n  if (once$$1) {\n    var oldHandler = _handler;\n    var _target = target$1; // save current target element in closure\n    _handler = function handler(ev) {\n      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, _handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n}\n\nfunction remove$2(event, handler, capture, _target) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return;\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps(oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return;\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) {\n        vnode.children.length = 0;\n      }\n      if (cur === oldProps[key]) {\n        continue;\n      }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue(elm, vnode, checkVal) {\n  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));\n}\n\nfunction isDirty(elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try {\n    notInFocus = document.activeElement !== elm;\n  } catch (e) {}\n  return notInFocus && elm.value !== checkVal;\n}\n\nfunction isInputChanged(elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number) {\n    return toNumber(value) !== toNumber(newVal);\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim();\n  }\n  return value !== newVal;\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res;\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData(data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle ? extend(data.staticStyle, style) : style;\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding(bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle);\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle);\n  }\n  return bindingStyle;\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle(vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if (styleData = normalizeStyleData(vnode.data)) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while (parentNode = parentNode.parent) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res;\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function setProp(el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && prop in emptyStyle) {\n    return prop;\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name;\n    }\n  }\n});\n\nfunction updateStyle(oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n    return;\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.add(c);\n      });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass(el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) {\n        return el.classList.remove(c);\n      });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition(def$$1) {\n  if (!def$$1) {\n    return;\n  }\n  /* istanbul ignore else */\n  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res;\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1);\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: name + \"-enter\",\n    enterToClass: name + \"-enter-to\",\n    enterActiveClass: name + \"-enter-active\",\n    leaveClass: name + \"-leave\",\n    leaveToClass: name + \"-leave-to\",\n    leaveActiveClass: name + \"-leave-active\"\n  };\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;\n\nfunction nextFrame(fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass(el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass(el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds(el, expectedType, cb) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) {\n    return cb();\n  }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function end() {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function onEnd(e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo(el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  };\n}\n\nfunction getTimeout(delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i]);\n  }));\n}\n\nfunction toMs(s) {\n  return Number(s.slice(0, -1)) * 1000;\n}\n\n/*  */\n\nfunction enter(vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return;\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return;\n  }\n\n  var startClass = isAppear && appearClass ? appearClass : enterClass;\n  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave(vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm();\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return;\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave() {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return;\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration(val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n  } else if (isNaN(val)) {\n    warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n  }\n}\n\nfunction isValidDuration(val) {\n  return typeof val === 'number' && !isNaN(val);\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength(fn) {\n  if (isUndef(fn)) {\n    return false;\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n  } else {\n    return (fn._length || fn.length) > 1;\n  }\n}\n\nfunction _enter(_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1(vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function cb() {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated(el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) {\n        return !looseEqual(o, prevOptions[i]);\n      })) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected(el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n    return;\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return;\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction getValue(option) {\n  return '_value' in option ? option._value : option.value;\n}\n\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd(e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) {\n    return;\n  }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger(el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode(vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n}\n\nvar show = {\n  bind: function bind(el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update(el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) {\n      return;\n    }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild(vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children));\n  } else {\n    return vnode;\n  }\n}\n\nfunction extractTransitionData(comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data;\n}\n\nfunction placeholder(h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    });\n  }\n}\n\nfunction hasParentTransition(vnode) {\n  while (vnode = vnode.parent) {\n    if (vnode.data.transition) {\n      return true;\n    }\n  }\n}\n\nfunction isSameChild(child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag;\n}\n\nfunction isAsyncPlaceholder(node) {\n  return node.isComment && node.asyncFactory;\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render(h) {\n    var this$1 = this;\n\n    var children = this.$options._renderChildren;\n    if (!children) {\n      return;\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) {\n      return c.tag || isAsyncPlaceholder(c);\n    });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return;\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn('invalid <transition> mode: ' + mode, this.$parent);\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild;\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild;\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild);\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + this._uid + \"-\";\n    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) {\n      return d.name === 'show';\n    })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild);\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild;\n        }\n        var delayedLeave;\n        var performLeave = function performLeave() {\n          delayedLeave();\n        };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        });\n      }\n    }\n\n    return rawChild;\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render(h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n          warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children);\n  },\n\n  beforeUpdate: function beforeUpdate() {\n    // force removing pass\n    this.__patch__(this._vnode, this.kept, false, // hydrating\n    true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated() {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || (this.name || 'v') + '-move';\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return;\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove(el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false;\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove;\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) {\n          removeClass(clone, cls);\n        });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return this._hasMove = info.hasTransform;\n    }\n  }\n};\n\nfunction callPendingCbs(c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition(c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation(c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating);\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n    console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode(content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\"/>\";\n  return div.innerHTML.indexOf(encoded) > 0;\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n});\n\nfunction parseText(text, delimiters) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while (match = tagRE.exec(text)) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push(\"_s(\" + exp + \")\");\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+');\n}\n\n/*  */\n\nfunction transformNode(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData(el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + el.staticClass + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + el.classBinding + \",\";\n  }\n  return data;\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1(el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1(el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + el.staticStyle + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + el.styleBinding + \"),\";\n  }\n  return data;\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\nvar modules$1 = [klass$1, style$1];\n\n/*  */\n\nfunction text(el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n  }\n}\n\n/*  */\n\nfunction html(el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode(html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent;\n  }\n};\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n// attr value double quotes\n/\"([^\"]*)\"+/.source,\n// attr value, single quotes\n/'([^']*)'+/.source,\n// attr value, no quotes\n/([^\\s\"'=<>`]+)/.source];\nvar attribute = new RegExp('^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?');\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {\n  return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n};\n\nfunction decodeAttr(value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) {\n    return decodingMap[match];\n  });\n}\n\nfunction parseHTML(html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue;\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue;\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue;\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue;\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue;\n        }\n      }\n\n      var text = void 0,\n          rest = void 0,\n          next = void 0;\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) {\n            break;\n          }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return '';\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n      }\n      break;\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance(n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag() {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match;\n      }\n    }\n  }\n\n  function handleStartTag(match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') {\n          delete args[3];\n        }\n        if (args[4] === '') {\n          delete args[4];\n        }\n        if (args[5] === '') {\n          delete args[5];\n        }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, options.shouldDecodeNewlines)\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag(tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) {\n      start = index;\n    }\n    if (end == null) {\n      end = index;\n    }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break;\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' && (i > pos || !tagName) && options.warn) {\n          options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse(template, options) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce(msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre(element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldKeepComment: options.comments,\n    start: function start(tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints(el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) {\n          // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end() {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars(text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce('Component template requires a root element, rather than just text.');\n          } else if (text = text.trim()) {\n            warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n          }\n        }\n        return;\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n        return;\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n      // only preserve whitespace if its not right after a starting tag\n      : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment(text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root;\n}\n\nfunction processPre(el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs(el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey(el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef(el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor(el) {\n  var exp;\n  if (exp = getAndRemoveAttr(el, 'v-for')) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\"Invalid v-for expression: \" + exp);\n      return;\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf(el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions(el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n  }\n}\n\nfunction findPrevElement(children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i];\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition(el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce(el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot(el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent(el) {\n  var binding;\n  if (binding = getBindingAttr(el, 'is')) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs(el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) {\n        // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') {\n              name = 'innerHTML';\n            }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n          }\n        }\n        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) {\n        // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else {\n        // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor(el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction parseModifiers(name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) {\n      ret[m.slice(1)] = true;\n    });\n    return ret;\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map;\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag(el) {\n  return el.tag === 'script' || el.tag === 'style';\n}\n\nfunction isForbiddenTag(el) {\n  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug(attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res;\n}\n\nfunction checkForAliasModel(el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize(root, options) {\n  if (!root) {\n    return;\n  }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1(keys) {\n  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n}\n\nfunction markStatic$1(node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n      return;\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots(node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n      node.staticRoot = true;\n      return;\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic(node) {\n  if (node.type === 2) {\n    // expression\n    return false;\n  }\n  if (node.type === 3) {\n    // text\n    return true;\n  }\n  return !!(node.pre || !node.hasBindings && // no dynamic bindings\n  !node.if && !node.for && // not v-if or v-for or v-else\n  !isBuiltInTag(node.tag) && // not a built-in\n  isPlatformReservedTag(node.tag) && // not a component\n  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n}\n\nfunction isDirectChildOfTemplateFor(node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false;\n    }\n    if (node.for) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function genGuard(condition) {\n  return \"if(\" + condition + \")return null;\";\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers(events, isNative, warn) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (process.env.NODE_ENV !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {\n      warn(\"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" + \"do not actually fire \\\"click\\\" events.\");\n    }\n    res += \"\\\"\" + name + \"\\\":\" + genHandler(name, handler) + \",\";\n  }\n  return res.slice(0, -1) + '}';\n}\n\nfunction genHandler(name, handler) {\n  if (!handler) {\n    return 'function(){}';\n  }\n\n  if (Array.isArray(handler)) {\n    return \"[\" + handler.map(function (handler) {\n      return genHandler(name, handler);\n    }).join(',') + \"]\";\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression ? handler.value : \"function($event){\" + handler.value + \"}\"; // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n    return \"function($event){\" + code + handlerCode + \"}\";\n  }\n}\n\nfunction genKeyFilter(keys) {\n  return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n}\n\nfunction genFilterCode(key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return \"$event.keyCode!==\" + keyVal;\n  }\n  var alias = keyCodes[key];\n  return \"_k($event.keyCode,\" + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + \")\";\n}\n\n/*  */\n\nfunction on(el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) {\n    return \"_g(\" + code + \",\" + dir.value + \")\";\n  };\n}\n\n/*  */\n\nfunction bind$1(el, dir) {\n  el.wrapData = function (code) {\n    return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState(options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) {\n    return !isReservedTag(el.tag);\n  };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\nfunction generate(ast, options) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: \"with(this){return \" + code + \"}\",\n    staticRenderFns: state.staticRenderFns\n  };\n}\n\nfunction genElement(el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state);\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state);\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state);\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0';\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state);\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code;\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic(el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n  return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n}\n\n// v-once\nfunction genOnce(el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state);\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break;\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\"v-once can only be used inside v-for that is keyed. \");\n      return genElement(el, state);\n    }\n    return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + (key ? \",\" + key : \"\") + \")\";\n  } else {\n    return genStatic(el, state);\n  }\n}\n\nfunction genIf(el, state, altGen, altEmpty) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n}\n\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\n  if (!conditions.length) {\n    return altEmpty || '_e()';\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n  } else {\n    return \"\" + genTernaryExp(condition.block);\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp(el) {\n    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n  }\n}\n\nfunction genFor(el, state, altGen, altHelper) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n  if (process.env.NODE_ENV !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n    state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n}\n\nfunction genData$2(el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) {\n    data += dirs + ',';\n  }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + el.key + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + el.ref + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + el.tag + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + genProps(el.props) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += genHandlers(el.events, false, state.warn) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += genHandlers(el.nativeEvents, true, state.warn) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + el.slotTarget + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += genScopedSlots(el.scopedSlots, state) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data;\n}\n\nfunction genDirectives(el, state) {\n  var dirs = el.directives;\n  if (!dirs) {\n    return;\n  }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']';\n  }\n}\n\nfunction genInlineTemplate(el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (el.children.length > 1 || ast.type !== 1)) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n      return \"function(){\" + code + \"}\";\n    }).join(',') + \"]}\";\n  }\n}\n\nfunction genScopedSlots(slots, state) {\n  return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n    return genScopedSlot(key, slots[key], state);\n  }).join(',') + \"])\";\n}\n\nfunction genScopedSlot(key, el, state) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state);\n  }\n  return \"{key:\" + key + \",fn:function(\" + String(el.attrsMap.scope) + \"){\" + \"return \" + (el.tag === 'template' ? genChildren(el, state) || 'void 0' : genElement(el, state)) + \"}}\";\n}\n\nfunction genForScopedSlot(key, el, state) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n  var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el, state) + '})';\n}\n\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n      return (altGenElement || genElement)(el$1, state);\n    }\n    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n    var gen = altGenNode || genNode;\n    return \"[\" + children.map(function (c) {\n      return gen(c, state);\n    }).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType(children, maybeComponent) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue;\n    }\n    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return needsNormalization(c.block);\n    })) {\n      res = 2;\n      break;\n    }\n    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n      return maybeComponent(c.block);\n    })) {\n      res = 1;\n    }\n  }\n  return res;\n}\n\nfunction needsNormalization(el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n}\n\nfunction genNode(node, state) {\n  if (node.type === 1) {\n    return genElement(node, state);\n  }if (node.type === 3 && node.isComment) {\n    return genComment(node);\n  } else {\n    return genText(node);\n  }\n}\n\nfunction genText(text) {\n  return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n  : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n}\n\nfunction genComment(comment) {\n  return \"_e(\" + JSON.stringify(comment.text) + \")\";\n}\n\nfunction genSlot(el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n  var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n    return camelize(a.name) + \":\" + a.value;\n  }).join(',') + \"}\";\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')';\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent(componentName, el, state) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n}\n\nfunction genProps(props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n  }\n  return res.slice(0, -1);\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines(text) {\n  return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors(ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors;\n}\n\nfunction checkNode(node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          } else {\n            checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent(exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor(node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier(ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n  }\n}\n\nfunction checkExpression(exp, text, errors) {\n  try {\n    new Function(\"return \" + exp);\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n    } else {\n      errors.push(\"invalid expression: \" + text.trim());\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction(code, errors) {\n  try {\n    return new Function(code);\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop;\n  }\n}\n\nfunction createCompileToFunctionFn(compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions(template, options, vm) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters ? String(options.delimiters) + template : template;\n    if (cache[key]) {\n      return cache[key];\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n          return \"- \" + e;\n        }).join('\\n') + '\\n', vm);\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) {\n          return tip(msg, vm);\n        });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors);\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n          var err = ref.err;\n          var code = ref.code;\n\n          return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n        }).join('\\n'), vm);\n      }\n    }\n\n    return cache[key] = res;\n  };\n}\n\n/*  */\n\nfunction createCompilerCreator(baseCompile) {\n  return function createCompiler(baseOptions) {\n    function compile(template, options) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled;\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    };\n  };\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile(template, options) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  };\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML;\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (el, hydrating) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n    return this;\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\"Template element not found or is empty: \" + options.template, this);\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this;\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(this._name + \" compile\", 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating);\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML) {\n    return el.outerHTML;\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML;\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(10)))\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLjIuNC4yQHZ1ZS9kaXN0L3Z1ZS5jb21tb24uanM/YzFmMCJdLCJuYW1lcyI6WyJpc1VuZGVmIiwidiIsInVuZGVmaW5lZCIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwidmFsdWUiLCJpc09iamVjdCIsIm9iaiIsIl90b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsImNhbGwiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidmFsIiwibiIsInBhcnNlRmxvYXQiLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJTdHJpbmciLCJ0b051bWJlciIsImlzTmFOIiwibWFrZU1hcCIsInN0ciIsImV4cGVjdHNMb3dlckNhc2UiLCJtYXAiLCJjcmVhdGUiLCJsaXN0Iiwic3BsaXQiLCJpIiwibGVuZ3RoIiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImhhc093blByb3BlcnR5IiwiaGFzT3duIiwia2V5IiwiY2FjaGVkIiwiZm4iLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwicmVwbGFjZSIsIl8iLCJjIiwidG9VcHBlckNhc2UiLCJjYXBpdGFsaXplIiwiY2hhckF0Iiwic2xpY2UiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsImJpbmQiLCJjdHgiLCJib3VuZEZuIiwiYSIsImwiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJBcnJheSIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJiIiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwia2V5cyIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXkiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsImNvbmZpZyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2xpZmVjeWNsZUhvb2tzIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJpc1Jlc2VydmVkIiwiY2hhckNvZGVBdCIsImRlZiIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwicGF0aCIsInRlc3QiLCJzZWdtZW50cyIsIndhcm4iLCJ0aXAiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImVycm9yIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm5hbWUiLCJvcHRpb25zIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsIm1hdGNoIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwiY29uc3RydWN0b3IiLCJwdXNoIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiaW5Ccm93c2VyIiwiaGFzUHJvdG8iLCJ3aW5kb3ciLCJVQSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJuYXRpdmVXYXRjaCIsIndhdGNoIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsImdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImdsb2JhbCIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJuZXh0VGljayIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJ0aW1lckZ1bmMiLCJuZXh0VGlja0hhbmRsZXIiLCJjb3BpZXMiLCJQcm9taXNlIiwicCIsInJlc29sdmUiLCJsb2dFcnJvciIsInRoZW4iLCJjYXRjaCIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJkYXRhIiwicXVldWVOZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJyZWplY3QiLCJfU2V0IiwiU2V0Iiwic2V0IiwiaGFzIiwiYWRkIiwiY2xlYXIiLCJ1aWQiLCJEZXAiLCJpZCIsInN1YnMiLCJhZGRTdWIiLCJzdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsImZvckVhY2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJvYnNlcnZlclN0YXRlIiwic2hvdWxkQ29udmVydCIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIml0ZW1zIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsInBhcmVudCIsImNoaWxkIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJ0eXBlIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwiY29tcHV0ZWQiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29udGV4dCIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiY2xvbmVWTm9kZXMiLCJ2bm9kZXMiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY2FwdHVyZSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJldmVudCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwiZmFjdG9yeSIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJkZWVwIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImNoZWNrT3B0aW9uVHlwZSIsIm9wdGlvbiIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY29tcHV0ZWRHZXR0ZXIiLCJoYW5kbGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJwcm92aWRlS2V5Iiwic291cmNlIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJfY29udGV4dCIsImgiLCJkIiwiY3JlYXRlRWxlbWVudCIsImluamVjdGlvbnMiLCJmdW5jdGlvbmFsT3B0aW9ucyIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0IiwicGFyZW50RWxtIiwicmVmRWxtIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsIiRtb3VudCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsImNpZCIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwibWVyZ2VIb29rcyIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwic3RhdGljUmVuZGVyRm5zIiwiZnJvbVBhcmVudCIsIm91cnMiLCJtZXJnZUhvb2skMSIsIm9uZSIsInR3byIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCJhcHBseU5TIiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJzbG90Tm9kZXMiLCJfcmVuZGVyZWQiLCJyZXNvbHZlRmlsdGVyIiwiY2hlY2tLZXlDb2RlcyIsImV2ZW50S2V5Q29kZSIsImJ1aWx0SW5BbGlhcyIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImRvbVByb3BzIiwiJGV2ZW50IiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiYmluZE9iamVjdExpc3RlbmVycyIsImV4aXN0aW5nIiwiaW5pdFJlbmRlciIsInJlbmRlckNvbnRleHQiLCJfYyIsIiRjcmVhdGVFbGVtZW50IiwicGFyZW50RGF0YSIsInJlbmRlck1peGluIiwiJG5leHRUaWNrIiwicmVmIiwicmVuZGVyRXJyb3IiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwiX2ciLCJ1aWQkMSIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsInBhdHRlcm5UeXBlcyIsIlJlZ0V4cCIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJjdXJyZW50IiwiZmlsdGVyIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsImRlbGV0ZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJuZXh0U2libGluZyIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJub2RlT3BzIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJob29rcyIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaW5QcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJwcmUiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJhbmNlc3RvciIsIl9zY29wZUlkIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwiZWxtVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJiYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsIm5vZGVUeXBlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImRpciIsImNhbGxIb29rJDEiLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwiYWRkQXR0ciIsImFkZERpcmVjdGl2ZSIsImFyZyIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJwcmV2ZW50IiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldEJpbmRpbmdBdHRyIiwiZ2V0U3RhdGljIiwiZHluYW1pY1ZhbHVlIiwiZ2V0QW5kUmVtb3ZlQXR0ciIsInN0YXRpY1ZhbHVlIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJtb2RlbFJzIiwicGFyc2VNb2RlbCIsImlkeCIsImNociIsImluZGV4JDEiLCJleHByZXNzaW9uUG9zIiwiZXhwcmVzc2lvbkVuZFBvcyIsImxhc3RJbmRleE9mIiwiZW9mIiwibmV4dCIsImlzU3RyaW5nU3RhcnQiLCJwYXJzZVN0cmluZyIsInBhcnNlQnJhY2tldCIsInN1YnN0cmluZyIsImluQnJhY2tldCIsInN0cmluZ1F1b3RlIiwid2FybiQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIl93YXJuIiwiZHluYW1pY1R5cGUiLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwidGFyZ2V0JDEiLCJhZGQkMSIsIm9sZEhhbmRsZXIiLCJldiIsInJlbW92ZSQyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJkZWYkJDEiLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsImVuZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJOdW1iZXIiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsImlzVGV4dElucHV0VHlwZSIsInZtb2RlbCIsInRyaWdnZXIiLCJtb2RlbCQxIiwiYmluZGluZyIsInNldFNlbGVjdGVkIiwiX3ZPcHRpb25zIiwiZ2V0VmFsdWUiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvblN0YXJ0IiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwic29tZSIsIm8iLCJpc011bHRpcGxlIiwic2VsZWN0ZWRJbmRleCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsImtleSQxIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiYm9keSIsImYiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJzaG91bGREZWNvZGUiLCJjb250ZW50IiwiZW5jb2RlZCIsImRpdiIsImlubmVySFRNTCIsInNob3VsZERlY29kZU5ld2xpbmVzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwib3BlbiIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJsYXN0SW5kZXgiLCJleGVjIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsIm1vZHVsZXMkMSIsImh0bWwiLCJkaXJlY3RpdmVzJDEiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJiYXNlT3B0aW9ucyIsImV4cGVjdEhUTUwiLCJkZWNvZGVyIiwiaGUiLCJkZWNvZGUiLCJzaW5nbGVBdHRySWRlbnRpZmllciIsInNpbmdsZUF0dHJBc3NpZ24iLCJzaW5nbGVBdHRyVmFsdWVzIiwiYXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInJlIiwicGFyc2VIVE1MIiwic3RhY2siLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50IiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJjaGFycyIsImVuZFRhZ0xlbmd0aCIsInN0YWNrZWRUYWciLCJyZVN0YWNrZWRUYWciLCJyZXN0JDEiLCJhbGwiLCJ1bmFyeVNsYXNoIiwidW5hcnkiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsImFyZ1JFIiwiYmluZFJFIiwibW9kaWZpZXJSRSIsImRlY29kZUhUTUxDYWNoZWQiLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsInBhcnNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblZQcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImVsZW1lbnQiLCJjb21tZW50cyIsImd1YXJkSUVTVkdCdWciLCJtYWtlQXR0cnNNYXAiLCJpc0ZvcmJpZGRlblRhZyIsImZvcmJpZGRlbiIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJwcm9jZXNzS2V5IiwicGxhaW4iLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJpJDIiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsImNoZWNrSW5Gb3IiLCJpbk1hdGNoIiwiZm9yIiwiYWxpYXMiLCJpdGVyYXRvck1hdGNoIiwiaXRlcmF0b3IxIiwiaXRlcmF0b3IyIiwiZmluZFByZXZFbGVtZW50IiwiY29uZGl0aW9uIiwiaWZDb25kaXRpb25zIiwic2xvdE5hbWUiLCJpc1Byb3AiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJzcGFjZSIsInVwIiwicmlnaHQiLCJkb3duIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwic2VsZiIsImN0cmwiLCJzaGlmdCIsImFsdCIsIm1ldGEiLCJtaWRkbGUiLCJnZW5IYW5kbGVycyIsImdlbkhhbmRsZXIiLCJpc01ldGhvZFBhdGgiLCJpc0Z1bmN0aW9uRXhwcmVzc2lvbiIsImdlbk1vZGlmaWVyQ29kZSIsImdlbktleUZpbHRlciIsImhhbmRsZXJDb2RlIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsInBhcnNlSW50Iiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJtYXliZUNvbXBvbmVudCIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsInNjb3BlIiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJlbCQxIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInByb2hpYml0ZWRLZXl3b3JkUkUiLCJ1bmFyeU9wZXJhdG9yc1JFIiwiaWRlbnRSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJGdW5jdGlvbiIsImNyZWF0ZUZ1bmN0aW9uIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJyZWYkMSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiY29udGFpbmVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0E7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUNBLFNBQVNBLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFNBQU9BLE1BQU1DLFNBQU4sSUFBbUJELE1BQU0sSUFBaEM7QUFDRDs7QUFFRCxTQUFTRSxLQUFULENBQWdCRixDQUFoQixFQUFtQjtBQUNqQixTQUFPQSxNQUFNQyxTQUFOLElBQW1CRCxNQUFNLElBQWhDO0FBQ0Q7O0FBRUQsU0FBU0csTUFBVCxDQUFpQkgsQ0FBakIsRUFBb0I7QUFDbEIsU0FBT0EsTUFBTSxJQUFiO0FBQ0Q7O0FBRUQsU0FBU0ksT0FBVCxDQUFrQkosQ0FBbEIsRUFBcUI7QUFDbkIsU0FBT0EsTUFBTSxLQUFiO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNLLFdBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCO0FBQzNCLFNBQ0UsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUNBLE9BQU9BLEtBQVAsS0FBaUIsUUFEakIsSUFF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QXVCeHNDLEVBQXZCLEVBQTJCO0FBQ3pCLE1BQUlBLEdBQUd5c0MsU0FBUCxFQUFrQjtBQUNoQixXQUFPenNDLEdBQUd5c0MsU0FBVjtBQUNELEdBRkQsTUFFTztBQUNMLFFBQUlDLFlBQVl0eEMsU0FBUzRaLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQTAzQixjQUFVdnJCLFdBQVYsQ0FBc0JuaEIsR0FBR3U2QixTQUFILENBQWEsSUFBYixDQUF0QjtBQUNBLFdBQU9tUyxVQUFVdlIsU0FBakI7QUFDRDtBQUNGOztBQUVEeGYsTUFBTWd3QixPQUFOLEdBQWdCQyxrQkFBaEI7O0FBRUFlLE9BQU9DLE9BQVAsR0FBaUJqeEIsS0FBakIsQyIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNC4yXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogICovXG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3QsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG4gKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAqIHdpdGggLi4ucmVzdCAoaHR0cHM6Ly9mbG93Lm9yZy9ibG9nLzIwMTcvMDUvMDcvU3RyaWN0LUZ1bmN0aW9uLUNhbGwtQXJpdHkvKVxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyoqXG4gKiBSZXR1cm4gc2FtZSB2YWx1ZVxuICovXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxvb3NlRXF1YWwoYXJyW2ldLCB2YWwpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG52YXIgQVNTRVRfVFlQRVMgPSBbXG4gICdjb21wb25lbnQnLFxuICAnZGlyZWN0aXZlJyxcbiAgJ2ZpbHRlcidcbl07XG5cbnZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobnVsbCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmaXggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuLyoqXG4gKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAqL1xudmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuICB2YXIgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgdGltZXJGdW5jO1xuXG4gIGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4obmV4dFRpY2tIYW5kbGVyKS5jYXRjaChsb2dFcnJvcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4uY2FsbCh0aGlzLCBwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucykge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IGluamVjdFtpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7fSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKGNvbXAuX19lc01vZHVsZSAmJiBjb21wLmRlZmF1bHQpIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBjaGlsZC5kYXRhICYmIGNoaWxkLmRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGNoaWxkLmRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5zZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycztcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycztcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICB9XG5cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGFuZGxlcnNbaV0uY2FsbCh2bSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tPcHRpb25UeXBlICh2bSwgbmFtZSkge1xuICB2YXIgb3B0aW9uID0gdm0uJG9wdGlvbnNbbmFtZV07XG4gIGlmICghaXNQbGFpbk9iamVjdChvcHRpb24pKSB7XG4gICAgd2FybihcbiAgICAgIChcImNvbXBvbmVudCBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzaG91bGQgYmUgYW4gb2JqZWN0LlwiKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpIHx8IGNvbmZpZy5pc1Jlc2VydmVkQXR0cihrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnY29tcHV0ZWQnKTtcbiAgdmFyIHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciB8fCBub29wLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICdtZXRob2RzJyk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hlY2tPcHRpb25UeXBlKHZtLCAnd2F0Y2gnKTtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBrZXlPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChrZXlPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzb3VyY2UpIHtcbiAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwge30pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHBhcmVudDogY29udGV4dCxcbiAgICBsaXN0ZW5lcnM6IGRhdGEub24gfHwge30sXG4gICAgaW5qZWN0aW9uczogcmVzb2x2ZUluamVjdChDdG9yLm9wdGlvbnMuaW5qZWN0LCBjb250ZXh0KSxcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdm5vZGUuZnVuY3Rpb25hbE9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgJiYgd2FybihcbiAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhc1xuKSB7XG4gIHZhciBrZXlDb2RlcyA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5BbGlhcztcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG4gICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuICAgIHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChvdXJzLCBleGlzdGluZykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMsIG51bGwsIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGxpc3RlbmVycycsIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICBWdWUucHJvdG90eXBlLl9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbmZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDErKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICB2bS5fc2VsZiA9IHZtO1xuICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgIGluaXRFdmVudHModm0pO1xuICAgIGluaXRSZW5kZXIodm0pO1xuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgaW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcbiAgICBpbml0U3RhdGUodm0pO1xuICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICBjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKCh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSQzKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5ICh2bm9kZSkge1xuICBpZiAodm5vZGUpIHtcbiAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgKFxuICAgICAgICAodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG4gICAgICAgICh0aGlzLmV4Y2x1ZGUgJiYgbWF0Y2hlcyh0aGlzLmV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgIH1cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi40LjInO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG5cbi8qXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQlxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpblByZSA9IDA7XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGluUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpblByZSAmJlxuICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiYgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5pbmRleE9mKHRhZykgPiAtMSkgJiZcbiAgICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgID8gbm9kZU9wcy5jcmVhdGVFbGVtZW50TlModm5vZGUubnMsIHRhZylcbiAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBpblByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgICB9XG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIHZhciBpLCBqO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5kZXN0cm95KSkgeyBpKHZub2RlKTsgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhjaCk7XG4gICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAhYmFpbGVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIC8vIGNvbXBvbmVudCByb290IGVsZW1lbnQgcmVwbGFjZWQuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG4gICAgbW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXG4gICAgKTtcbiAgfVxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cbiAgdmFyIGV2ZW50cztcbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSwgbW9kaWZpZXJzOiBtb2RpZmllcnMgfTtcbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgaWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICh2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiJHNldChcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgXCIgKyAobW9kZWxScy5pZHgpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICB9XG59XG5cbi8qKlxuICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuICpcbiAqIGZvciBsb29wIHBvc3NpYmxlIGNhc2VzOlxuICpcbiAqIC0gdGVzdFxuICogLSB0ZXN0W2lkeF1cbiAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuICogLSB0ZXN0W1wiYVwiXVtpZHhdXG4gKiAtIHh4eC50ZXN0W2FbYV0udGVzdDFbaWR4XV1cbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuICpcbiAqL1xuXG52YXIgbGVuO1xudmFyIHN0cjtcbnZhciBjaHI7XG52YXIgaW5kZXgkMTtcbnZhciBleHByZXNzaW9uUG9zO1xudmFyIGV4cHJlc3Npb25FbmRQb3M7XG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBzdHIgPSB2YWw7XG4gIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbCxcbiAgICAgIGlkeDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zdWJzdHJpbmcoMCwgZXhwcmVzc2lvblBvcyksXG4gICAgaWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG4gICAgICAgIFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQxKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIHZhbHVlICsgXCI9JCRhLmNvbmNhdCgkJHYpKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtsZXkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwkMSxcbiAgc2hvdzogc2hvd1xufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgYSBzaW5nbGUgZWxlbWVudC9jb21wb25lbnQuXG4vLyBzdXBwb3J0cyB0cmFuc2l0aW9uIG1vZGUgKG91dC1pbiAvIGluLW91dClcblxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIHZhciBkYXRhID0ge307XG4gIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkICYmIChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICApIHtcbiAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICk7XG4gIH1cbn0sIDApO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgYT1cXFwiXCIgKyBjb250ZW50ICsgXCJcXFwiLz5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDBcbn1cblxuLy8gIzM2NjNcbi8vIElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IHNob3VsZERlY29kZSgnXFxuJywgJyYjMTA7JykgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4O1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMuam9pbignKycpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG4gIGlmIChzdGF0aWNTdHlsZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyogICovXG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxuICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxudmFyIGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgfVxufTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBzaW5nbGVBdHRySWRlbnRpZmllciA9IC8oW15cXHNcIic8Pi89XSspLztcbnZhciBzaW5nbGVBdHRyQXNzaWduID0gLyg/Oj0pLztcbnZhciBzaW5nbGVBdHRyVmFsdWVzID0gW1xuICAvLyBhdHRyIHZhbHVlIGRvdWJsZSBxdW90ZXNcbiAgL1wiKFteXCJdKilcIisvLnNvdXJjZSxcbiAgLy8gYXR0ciB2YWx1ZSwgc2luZ2xlIHF1b3Rlc1xuICAvJyhbXiddKiknKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBubyBxdW90ZXNcbiAgLyhbXlxcc1wiJz08PmBdKykvLnNvdXJjZVxuXTtcbnZhciBhdHRyaWJ1dGUgPSBuZXcgUmVnRXhwKFxuICAnXlxcXFxzKicgKyBzaW5nbGVBdHRySWRlbnRpZmllci5zb3VyY2UgK1xuICAnKD86XFxcXHMqKCcgKyBzaW5nbGVBdHRyQXNzaWduLnNvdXJjZSArICcpJyArXG4gICdcXFxccyooPzonICsgc2luZ2xlQXR0clZhbHVlcy5qb2luKCd8JykgKyAnKSk/J1xuKTtcblxuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXG4vLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xudmFyIHFuYW1lQ2FwdHVyZSA9ICcoKD86JyArIG5jbmFtZSArICdcXFxcOik/JyArIG5jbmFtZSArICcpJztcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKCdePCcgKyBxbmFtZUNhcHR1cmUpO1xudmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKCdePFxcXFwvJyArIHFuYW1lQ2FwdHVyZSArICdbXj5dKj4nKTtcbnZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG52YXIgY29tbWVudCA9IC9ePCEtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMCk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcbiAgICAgICAgKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgaWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZzogdGFnLFxuICAgICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICAgICAgcGFyZW50OiBjdXJyZW50UGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH07XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgICAgICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cbiAgICAgICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgfSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJzsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgcG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gMyAmJiBsYXN0Tm9kZS50ZXh0ID09PSAnICcgJiYgIWluUHJlKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgZW5kUHJlKGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgY3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIHRleHQgPSBpblByZSB8fCB0ZXh0LnRyaW0oKVxuICAgICAgICA/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG4gICAgICAgIC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG4gICAgICAgIDogcHJlc2VydmVXaGl0ZXNwYWNlICYmIGNoaWxkcmVuLmxlbmd0aCA/ICcgJyA6ICcnO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb247XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAoZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCkge1xuICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXlxccyooW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbnZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxudmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cbnZhciBtb2RpZmllckNvZGUgPSB7XG4gIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgcHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG4gIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICBzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICBsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmUsXG4gIHdhcm5cbikge1xuICB2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBldmVudHNbbmFtZV07XG4gICAgLy8gIzUzMzA6IHdhcm4gY2xpY2sucmlnaHQsIHNpbmNlIHJpZ2h0IGNsaWNrcyBkbyBub3QgYWN0dWFsbHkgZmlyZSBjbGljayBldmVudHMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG5hbWUgPT09ICdjbGljaycgJiZcbiAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5tb2RpZmllcnMgJiYgaGFuZGxlci5tb2RpZmllcnMucmlnaHRcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiVXNlIFxcXCJjb250ZXh0bWVudVxcXCIgaW5zdGVhZCBvZiBcXFwiY2xpY2sucmlnaHRcXFwiIHNpbmNlIHJpZ2h0IGNsaWNrcyBcIiArXG4gICAgICAgIFwiZG8gbm90IGFjdHVhbGx5IGZpcmUgXFxcImNsaWNrXFxcIiBldmVudHMuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIHZhciBjb2RlID0gJyc7XG4gICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgID8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCIoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgcmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn07XG5cbi8qICAqL1xuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGUud2FybihcbiAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIGlmIChlbC5zbG90VGFyZ2V0KSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMsIHN0YXRlKSkgKyBcIixcIjtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICB2YXIgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gIHZhciBoYXNSdW50aW1lID0gZmFsc2U7XG4gIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoXG4gICAgZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxuICB9XG4gIHJldHVybiBcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifX1cIlxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiAoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxudmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycgJiYgIWlkZW50UkUudGVzdChpZGVudCkpIHtcbiAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxudmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxudmFyIG1vdW50ID0gVnVlJDMucHJvdG90eXBlLiRtb3VudDtcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKCgodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZSQzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzLy4yLjQuMkB2dWUvZGlzdC92dWUuY29tbW9uLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n");

/***/ }),

/***/ 26:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(16);
module.exports = __webpack_require__(14);


/***/ })

},[26]);